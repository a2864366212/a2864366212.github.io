<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PrimeJudge]]></title>
    <url>%2F2019%2F11%2F22%2FPrimeJudge%2F</url>
    <content type="text"><![CDATA[Miller_Rabin（米勒-拉宾）素数判别法：时间复杂度O(logn) 质数:是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 互质(互素：互质是公约数只有1的两个整数，叫做互质整数。公约数只有1的两个自然数，叫做互质自然数，后者是前者的特殊情形。 同余： 同余式是数论的基本概念之一，设m是给定的一个正整数，a、b是整数，若满足m|(a-b)，则称a与b对模m同余，记为a≡b(mod m)，或记为a≡b(m)。这个式子称为模m的同余式，若m∤ (a-b)，则称a、b对模m不同余，同余概念又常表达为： 1.a=b+km(k∈Z)； 2.a和b被m除时有相同的余数。 同余式的记号由高斯(Gauss,C.F.)于1800年首创,发表在他的数论专著《算术研究》之中。 快速幂：均见BasicAlgorithm post 快速积：均见BasicAlgorithm post 位运算：均见BasicAlgorithm post 费马小定理：设p是素数，a与p互素，则 a^{(p-1)}\equiv 1(mod p) 二次探测：如果p是素数，x是小于p的正整数，且x^{2}\equiv1(modp)那么要么x=1，要么x=p-1值得注意的是有一条推导结论(原论文长达500多页，我找不着，就不看了，只找到了引用该结论的其他文章)在如下算法流程中：有的d,r,n,a几个重要参数其中给出结论：]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knapsackproblem]]></title>
    <url>%2F2019%2F11%2F21%2FKnapsackproblem%2F</url>
    <content type="text"><![CDATA[0-1 背包问题给定n个重量为w_{1},w_{2},..,w_{n}的物品，价值为v_{1},v_{2},…,v_{n}的物品和容量为C的背包，求这个物品中一个最有价值的子集，使得在满足背包的容量的前提下，包内的总价值最大 方案一:递归求解递归遍历解空间树，枚举，2_{n}（会因为剪枝而大大减少）种情况 answer[1~n]=max(选择物品1:value[1]+answer[2~n] 但是背包容量减少，不选择物品1+answer[2~n]背包容量不变) #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; int n; int w[100],v[100]; int Enum(int index,int c) { if(c&lt;0) return 0; if(index&gt;n-1) return 0; if(c&gt;=w[index]) { return max( v[index]+Enum(index+1,c-w[index]),Enum(index+1,c) ); } else{ return Enum(index+1,c); } } int main() { cin&gt;&gt;n; int c; cin&gt;&gt;c; for(int i=0;i&lt;n;i++) { cin&gt;&gt;w[i]&gt;&gt;v[i]; } cout&lt;&lt;Enum(0,c); return 0; }]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LongestIncreasingSubsequence]]></title>
    <url>%2F2019%2F11%2F21%2FLongestIncreasingSubsequence%2F</url>
    <content type="text"><![CDATA[最长上升子序列两种方法介绍法一：dp状态转移法二：贪心+二分做法：思路：1. 求最长递增子序列的长度时，我们使用二分查找的方法求，具体的操作是维护一个辅助数组，这个辅助数组dp[k]中保存着当前已经获得最长递增子序列，k表示当前的辅助数组中递增序列的个数，当处理原数组中下一个元素data[i]时，1）若data[i] &gt; dp[k - 1]时， 直接dp[k++] = data[i];2) 否则，使用二分查找在dp中找到第一个不大于data[i]的元素的位置j, 使得dp[j] = data[i]; 方法1复杂度O(n_{2})理解State:Length[index][TailHeight]-&gt; 1. Length[index+1][TailHeight] 当前元素不能接在LIS后面，下一状态继承当前状态 2. Length[index+1][Height[index]]+1 or Length[index+1][TailHeight]当前元素能接在LIS后面，下一状态基于当前状态做出两种决策 分析一下最终结果 假如输入序列中有n个元素，那么记最后结果为dp[n]显然 dp[n]= max(dp[i,i\epsilon[1,n]]+ element[n]&gt;element[i]?1:0; ) dp[i]为 以element[i]结尾的序列问题的最优解 状态转移方程：dp[i]=max(dp[j,j\epsilon[1,i）])+ element[i]]&gt;element[j]?1:0; )answer:dpcin:element 如果已经求出前n-1个元素的最优解，那么可以求出前n个元素的最优解如果已经求出前n-2个元素的最优解，那么可以求出前n-1个元素的最优解….初始化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #define M 2000000 + 5 int a[M],f[M],b[M]; int ans,n,k; int main(){ scanf(&quot;%d&quot;,&amp;n); for ( int i = 1;i &lt;= n; ++ i){ scanf(&quot;%d&quot;,&amp;a[i]); f[i] = 1; } for ( int i = 2;i &lt;= n; ++ i) for ( int j = 1;j &lt; i; ++ j) if (a[j] &lt; a[i] &amp;&amp; f[j] + 1 &gt; f[i]) f[i] = f[j] + 1; for ( int i = 1;i &lt;= n; ++ i) if (f[i] &gt; ans) ans = f[i]; printf(&quot;%d\n&quot;,ans); } 方法2复杂度O(n\log n)1.lower_bound(起始地址，结束地址，要查找的数值) 返回的是大于或等于val的第一个元素位置 2.upper_bound(起始地址，结束地址，要查找的数值) 返回的是返回大于val的第一个元素位置 3.binary_search(起始地址，结束地址，要查找的数值) 返回的是是否存在这么一个数，是一个bool值。 1.2.两个函数的用法类似，在一个左闭右开的有序区间里进行二分查找，需要查找的值由第三个参数给出。 对于upper_bound来说，返回的是被查序列中第一个大于查找值的指针，也就是返回指向被查值&gt;查找值的最小指针，lower_bound则是返回的是被查序列中第一个大于等于查找值的指针，也就是返回指向被查值&gt;=查找值的最小指针。 不过除此之外，这两个函数还分别有一个重载函数，可以接受第四个参数。如果第四个参数传入greater&lt;Type&gt;()，其中Type改成对应类型，那么upper_bound则返回指向被查值&lt;查找值的最小指针，lower_bound则返回指向被查值&lt;=查找值的最小指针。 此外，如果你用上述两个函数三个参数的那种形式，记得那个左闭右开的区间要为非递减的顺序，如果你给第四个参数传入greater&lt;Type&gt;()，则区间为非递增的顺序。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int greedy[1000+5]; int a[1000+5]; int main() { memset(greedy,0,1005*sizeof(int)); memset(a,0,1005*sizeof(int)); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } greedy[0]=a[0]; int endIndex=0; for(int i=1;i&lt;n;i++) { if(a[i]&gt;greedy[endIndex]) { endIndex++; greedy[endIndex]=a[i]; } else{ if(a[i]&lt;greedy[endIndex]) {//??? a[upper_bound(greedy,greedy+endIndex+1,a[i])-&amp;(a[0])]=a[i]; } } } cout&lt;&lt;endIndex+1; /*cout&lt;&lt;binary_search(a,a+n,3)&lt;&lt;endl; cout&lt;&lt;upper_bound(a,a+n,3)-&amp;(a[0]); cout&lt;&lt;endl&lt;&lt;lower_bound(a,a+n,3)-a;*/ return 0; }]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search]]></title>
    <url>%2F2019%2F11%2F20%2FSearch%2F</url>
    <content type="text"><![CDATA[检索 假设k_{1},k_{2}……,k_{n}是互不相同的关键码值，有一个包含n条记录的集合C，形式如下(k_{1},I_{1}),(k_{2},I_{2}),……,(k_{n},I_{n})。其中I_{j}是与关键码值绑定的value 匹配分类精确匹配：检索关键码值与某个特定值匹配的记录范围查询：检索关键码值在某个指定范围内得到所有记录 检索算法顺序表和线性表方法顺序查找和折半查找顺序查找的时间性能： 等概率ASL_{ss}= 不等概率 二分检索法将dataList[i].Key与给定值K作比较三种情况 Key=K,检索成功 返回dataList[i] Key&gt;K,则改为查找dataList[i]的前半个表中查找 Key&lt;K,则改为查找dataList[i]的后半个表中查找散列：理想情况下O(1)树索引： 启发式规则：初始序列：ABCDEFGH访问模式：FDFGEGFADF 计数统计方法保持线性表按照访问频率排序：A(1)B(0)C(0)D(2)E(2)F(4)G(3)H(0) 排序后：FGDEABCH 移至前端访问某条记录，将该记录移至前端（刚访问过的元素很可能再被访问）F:FABCDEGHD:DFABCEGHF:FDABCEGHG:GFDABCEHE:EGFDABCH…ANSWER:EGFDABCH 转置将当前访问的记录与它在线性表中的前一条记录交换位置(访问某个元素，将其在线性表中的位置前移一位) 与‘移至前端’原理类似 哈希表哈希函数 Key-position映射]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graph]]></title>
    <url>%2F2019%2F11%2F15%2FGraph%2F</url>
    <content type="text"><![CDATA[图论V表示点 E表示边 图的两种常见实现方式：1.邻接矩阵2.邻接表 邻接矩阵Edge[n][n]则约定Edge[i][j]仅在 节点i与节点j之间有连线时候为1（有向图和无向图略有区别…无向图有联系即为双向，所以会把Edge[i][j]与Edge[j][i]均置为1，有向图则根据指向置为1） 邻接表无向图：简单来说就是图中每一个点拥有一个自己的链表，这个链表以自己为头结点，链表中其他的节点都是头结点的邻居点dest邻居link指向下一个邻居 有向图：有向图因为具有方向性，所以使用两个邻接表来分别表示某节点的出边和入边。出边表：第i个链表，是以该链表头结点为起点发出的边，指向各个邻居入边表：第i个链表，是以该链表头结点为终点的边，从各个邻居发出，在该头节点结束 术语有向图：边具有方向性，边限定从一个顶点指向另一个顶点尖括号&lt;&gt;表示顶点偶对:&lt; v1,v2 &gt;和&lt; v2,v1 &gt;表示两个不同的边 无向图：边无方向性圆括号()表示顶点偶对：( v1,v2 )和( v2,v1 )表示同一个边 稀疏图，密集图：边数的多少 完全图：若有n个顶点的无向图有n(n-1)/2条边，则此图为无向图（所有顶点两两之间都有边相连接）若有n个顶点的有向图有n(n-1)/2*2=n(n-1)条边，则此图为有向完全图（所有顶点两两之间都有边相连接） 邻接顶点：如果(u,v)是E(G)中的一条边，则称u和v互为邻接顶点权：某些图的边具有与之相关数，成为边的权.这种带权图称为网络 子图：设有两个图G=(V,E)，设有两个图G＝( V,E )和G‘＝( V’,E’)。若 V’属于V且 E’属于E , 则称图G’是图G的子图。即 拿出一个图中的某一些点和某一些边作为一个图（类比子集和全集） 顶点的的度：一个顶点的度是与他相连关联的边的条数。记作TD(v) 在有向图中，定点的度等于该顶点的出度与入度之和（虽然入度与出度的值一正一负来区分，但是这里是绝对值求和） 顶点v的入度和出度：入度：以v为终点的有向边的条数出度：以v为起点的有向边的条数 路径：在图 G＝(V, E) 中,若从顶点v_{i}出发, 沿一些边经过一些顶点 v_{p1},v_{p2},…,v_{pm}到达顶点v_{j} 。则称顶点序列 ( v_{i} v_{p1} v_{p2} ... v_{pm} v_{j} ) 为从顶点v_{i} 到顶点 v_{j} 的路径。它经过的边(v_{i} , v_{p1})、(v_{p1} , v_{p2})、...、(v_{pm} , v_{j})应是属于E的边。 路径长度非带权图的路径长度是指此路径上边的条数。带权图的路径长度是指路径上各边的权之和 简单路径若路径上各顶点 v_{1} , v_{2} ,..., v_{m} 均不互相重复, 则称这样的路径为简单路径。回路若路径上第一个顶点v_{1} 与最后一个顶点v_{m} 重合,则称这样的路径为回路或环。 极大连通子图和极小连通子图的定义及讲解极大连通子图，极小连通子图分量，显然是可能存在多个的但是若是极大连通子图，表征了其不应该被其他分量所包含（如果真有，那么就应该是那位来当极大连通子图了）极小连通子图类比补充：强连通图只有一个强连通分量，即本身。 连通图与连通分量在无向图中, 若从顶点v_{1}到顶点v_{2}有路径, 则称顶点v_{1}与v_{2}是连通的。如果图中任意一对顶点都是连通的, 则称此图是连通图。非连通图的极大连通子图叫做连通分量 强连通图与强连通分量在有向图中, 若对于每一对顶点v_{i} 和v_{j} , 都存在一条从v_{i} 到v_{j} 和从v_{j} 到v_{i} 的路径, 则称此图是强连通图。非强连通图的极大强连通子图叫做强连通分量。 生成树一个连通图的生成树是它的极小连通子图，在n个顶点的情形下，有n-1条边。但有向图则可能得到它的由若干有向树组成的生成森林。 不讨论的图（课程） 图的遍历从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历 ( Graph Traversal )。 图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 为了避免重复访问，可设置一个标志顶点是否被访问过的标志位，它的初始状态为 0，在图的遍历过程中，一旦某一个顶点 i被访问，就立即让该顶点标志位为 1，防止它被多次访问。 DFS（一直往前走，直到走不通）栈实现从深度优先搜索遍历连通图的过程来看，类似于树的先根遍历； 邻接表表示时，查找所有顶点的邻接点所需时间为O(E)，访问顶点的邻接点所花时间为O（V）,此时，总的时间复杂度为O(V+E)。 邻接矩阵表示时，查找每个顶点的邻接点所需时间为O(V)，要查找整个矩阵，故总的时间度为O(V^2)。 v为图的顶点数，E为边数。 BFS队列实现（水面上滴一滴水，中心逐层向外扩展）邻接表形式存储时，每个顶点均需搜索一次，时间复杂度T1=O（v），从一个顶点开始搜索时，开始搜索，访问未被访问过的节点。最坏的情况下，每个顶点至少访问一次，每条边至少访问1次，这是因为在搜索的过程中，若某结点向下搜索时，其子结点都访问过了，这时候就会回退，故时间复 杂度为O(E)，算法总的时间复 度为O(|V|+|E|)。 邻接矩阵存储方式时，查找每个顶点的邻接点所需时间为O(V)，即该节点所在的该行该列。又有n个顶点，故算总的时间复杂度为O(|V|^2)。 有向图的拓扑排序例：大学生的专业培养计划（学习概率论的基础是高数1和高数2，即前置课程） 定义AOV网——用顶点表示活动，用弧表示活动间优先关系的有向图称为顶点表示活动的网(Activity On Vertex network)，简称AOV网，若&lt; vi,vj &gt;是图中有向边，则vi是vj的直接前驱；vj是vi的直接后继AOV网中不允许有回路，这意味着某项活动以自己为先决条件 拓扑排序把AOV网络中各顶点按照它们相互之间的优先关系排列成一个线性序列的过程 检测AOV网中是否存在环方法：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环（） 拓扑排序的方法 在有向图中选一个没有前驱的顶点且输出之 从图中删除该顶点和所有以它为起点的弧 重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止即：当前可以进入排序序列的节点一定符合条件：其没有前驱节点（要么是十分基础的课程，没有前置课程就能开始学习；要么就是其前置课程已经学习完毕，可以开始学习该课程） Kruskal 算法Kruskal 算法也是一个简单的贪心算法考虑问题的出发点为使得生成树的权值和最小，则应尽量使得每条加入生成树的边尽可能小 首先，将顶点集分为|V| 个等价类，每个等价类包括一个顶点 然后，以权的大小为序处理各条边。如果某条边连接两个不同等价类的顶点，则这条边被加入MST ，两个等价类也被合为一个3.反复执行此过程直至只余下一个等价类。 Kruskal 算法的关键技术:对边(权)进行贪心 取权值最小的边首先对边进行完全排序，使用最小值堆来实现，一次取一条边。实际上在完成MST 前仅需访问一小部分边。 确定两个顶点是否属于同一等价类可以树的基于父指针表示法的UNION/FIND算法 例子：]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1090]]></title>
    <url>%2F2019%2F11%2F10%2FLuoguP1090%2F</url>
    <content type="text"><![CDATA[P1090 合并果子水题 (๑•̀ㅂ•́)و✧ 优先队列 直接贪心从头来过… #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;fruit; int main() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { int weight; cin&gt;&gt;weight; fruit.push(weight); } int ans=0; while(fruit.size()!=1) { int w1,w2; w1=fruit.top(); fruit.pop(); w2=fruit.top(); fruit.pop(); ans+=w1+w2; fruit.push(w1+w2); } cout&lt;&lt;ans; return 0; }]]></content>
      <tags>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Greedy]]></title>
    <url>%2F2019%2F11%2F10%2FGreedy%2F</url>
    <content type="text"><![CDATA[贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关 P1090 合并果子优先队列（使用stl写好的priority_queue）先出队列元素不是先进队列的元素，而是队列中优先级最高的元素代码 priority_queue基本用法： //升序队列 push小的优先 小的在堆顶 priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //降序队列 push大的优先 大的在堆顶 也是默认情况 priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q; struct node{ int x; bool operator&lt;(const tmp1&amp; a) const { return x &lt; a.x; // this object 的优先级 小于 a的优先级 } }]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BinSearchTree]]></title>
    <url>%2F2019%2F11%2F10%2FBinSearchTree%2F</url>
    <content type="text"><![CDATA[二叉检索树二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。可以实现字典的功能，通过将关键码与值绑定（可以将不可比较大小的值，变得可比，大概～(￣▽￣～)(～￣▽￣)～）二分检索树的时间复杂度为\theta (\log n) 插入操作key值如果小于当前节点的k值，往右边深入，否则往左边深入，直到成为叶子节点 删除操作step1:deletemin()//删除树中的最小值根据树的特性，一直向左子树深入，知道某个节点没有左子节点，则该节点为树中最小节点.则欲删除该节点，只需使其父节点的leftChild指针 直接指向该节点的右子树，即可完成删除.且不破坏BST树的结构（其父节点一定大于等于其左子树中各节点） step2:1.如果要删除的节点R没有子节点，那么只需要把其父节点指向R的指针，指向NULL即可2.如果要删除的节点R只有一个子节点，那么只需要把其父节点指向R的指针，指向R唯一的一颗子树即可3.如果要删除的节点R有两个子节点，较好地解决办法是从某棵子树中，找出一个R的替代者替代者的选取：大于(或等于)被替换值的最小者]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman]]></title>
    <url>%2F2019%2F11%2F09%2FHuffman%2F</url>
    <content type="text"><![CDATA[Huffman树设根树T有t片树叶v_{1},v_{2},..,v_{t},给每片树叶赋一个权值w_{1},w_{2},...,w_{t},则成为T赋权二叉树，其中l(v_{i})为叶子节点v_{i}的长度（节点到根节点路径长度），如果存在一种赋权方式，使得\sum_{i=1}^{t}w_{i}l(v_{i})的值（带权路径和）达到最小，则称这棵树为最优二叉树，或称Huffman树. 构造方法(1).对所有权值从低到高排序.(2).找出两个最小的权值，记为w_{1},w_{2}(3).用(w_{1}+w_{2} 代替w_{1}与w_{2}),产生新的队列(4).若队列中的点数大于1，则回到第一步，否则进行下一步. (5).逆序将以上组合过程画出来得到Huffman树 注意点构造时为保证唯一性，要求”左小右大，组合优先，左0右1，不足补0”左小右大：值权值小的画左边，权值大的画右边组合优先：如果某两个权值相同，则组合出来的节点优先（作为左子节点，画在左边）左0右1：是指向左儿子的边的编号为0， 指向右儿子的边编号为1不足补零：译码时使用，在末尾添加适当0以使得可以译码码]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1162]]></title>
    <url>%2F2019%2F11%2F09%2FLuoguP1162%2F</url>
    <content type="text"><![CDATA[模板题目：和Leetcode T130的解法只需要改一下参数就可 #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; using namespace std; void DFS(int r,int c,vector&lt;vector&lt;char&gt; &gt;&amp; board) { if(r&lt;0||r&gt;=board.size()||c&lt;0 ||c&gt;=board[0].size()||board[r][c]==&#39;1&#39; ||board[r][c]==&#39;H&#39;) { return ; } board[r][c]=&#39;H&#39;; DFS(r+1,c,board); DFS(r-1,c,board); DFS(r,c+1,board); DFS(r,c-1,board); } void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) { if(board.size()&lt;1||board[0].size()&lt;1) return ; for(int i=0;i&lt;board[0].size();i++) DFS(0,i,board); for(int i=0;i&lt;board[0].size();i++) DFS(board.size()-1,i,board); for(int i=0;i&lt;board.size();i++) DFS(i,0,board); for(int i=0;i&lt;board.size();i++) DFS(i,board[0].size()-1,board); for(int i=0;i&lt;board.size();i++) { for(int j=0;j&lt;board[0].size();j++) { if(board[i][j]==&#39;H&#39;) board[i][j]=&#39;0&#39;; else{ if(board[i][j]==&#39;0&#39;) board[i][j]=&#39;2&#39;; } } } } int main() { int n; cin&gt;&gt;n; vector&lt;vector&lt;char&gt; &gt;board; vector&lt;char&gt;temp; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { char ch; cin&gt;&gt;ch; temp.push_back(ch); } board.push_back(temp); temp.erase(temp.begin(),temp.end()); } solve(board); for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(j==0) cout&lt;&lt;board[i][j]; else{ cout&lt;&lt;&#39; &#39;&lt;&lt;board[i][j]; } } if(i!=n-1) cout&lt;&lt;endl; } return 0; } 真就是只改了下参数。。。。水题]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode127]]></title>
    <url>%2F2019%2F11%2F09%2FLeetcode127%2F</url>
    <content type="text"><![CDATA[思路分析转化为图来做两节点能转化，说明两节点连通，所以该问题变成，求图中begin节点和end节点是否可达，可达的最短路径求解1.建图2.BFS遍历图 class Solution { public: map]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNUOJ2826]]></title>
    <url>%2F2019%2F11%2F09%2FHNUOJ2826%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode130]]></title>
    <url>%2F2019%2F11%2F08%2FLeetcode130%2F</url>
    <content type="text"><![CDATA[130.被围绕的区域被围绕的区域.题目还是很简单的：就沿着边沿做几次DFS，把所有和边沿连同的路径上的’O’标记出来，剩下的’O’就是被包围起来的，将其翻转为’X’即可 class Solution { public: void DFS(int r,int c,vector]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1141]]></title>
    <url>%2F2019%2F11%2F08%2FLuoguP1141%2F</url>
    <content type="text"><![CDATA[P1141 01迷宫题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入格式第1行为两个正整数n,m 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 输出格式m行，对于每个询问输出相应答案。 输入输出样例输入 2 2 01 10 1 1 2 2 输出 4 4 先分析一下，可以发现，对于某一种遍历方式，所经过的节点都共享该遍历方式；（无论从哪一点出发，总会按照该方式遍历迷宫）并且很容易知道，某点有且仅有一种遍历迷宫方式（因为每种方案总是完全的） 所以可以少算很多点，打表做 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream using namespace std; int n,m,ans[100002],x,y,node[1002][1002]; char s[1002][1002]; void dfs(int row,int col,int val,int index){ if (row&lt;0 || row&gt;=n || col&lt;0 || col&gt;=n || node[row][col]!=-1/*已经被一种方案遍历过*/ || s[row][col]-&#39;0&#39;!=val) return; node[row][col]=index;//路径上的点指向同一answer,共享答案 ans[index]++;//改节点为ans[index]贡献一个节点数 dfs(row-1,col,!val,index); dfs(row+1,col,!val,index); dfs(row,col-1,!val,index); dfs(row,col+1,!val,index); } int main() { cin&gt;&gt;n&gt;&gt;m; for (int i=0;i&lt;n;i++) scanf(&quot;%s&quot;,s[i]); memset(node,-1,sizeof(node)); for(int i=0;i&lt;m;i++) { cin&gt;&gt;x&gt;&gt;y; x--; y--; if (node[x][y]==-1) dfs(x,y,s[x][y]-&#39;0&#39;,i); else ans[i]=ans[node[x][y]]; } for (int i=0;i&lt;m;i++) cout&lt;&lt;ans[i]&lt;&lt;endl; return 0; }]]></content>
      <tags>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFSandDFS]]></title>
    <url>%2F2019%2F11%2F07%2FBFSandDFS%2F</url>
    <content type="text"><![CDATA[BFSandDFSa)迷宫求解（最少步数）b)水池数目(NYOJ27)c)图像有用区域(NYOJ92)d)树的前序中序后序遍历 DFS深度优先搜索上例子寻找二叉树上从根结点到给定结点的路径： 一.递归实现/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: stack&lt;TreeNode*&gt;P,Q; bool PFlag=false,QFlag=false; void DFS(TreeNode* root, TreeNode* goal,stack&lt;TreeNode*&gt;&amp;road,bool&amp;HasFind) { /*对树DFS寻找两个目标节点，然后存储路径，仅为寻找到最近的共同祖先（要不然root就是所有的祖先，那还找啥）*/ if(HasFind)//已经在别的地方找到了 return; if(root==goal)//现在刚刚找到 { HasFind=true;//flag置为1 road.push(root); return; } road.push(root); if(root-&gt;left)//DFS非空左子树 { DFS(root-&gt;left,goal,road,HasFind); if(!HasFind) road.pop();//子树中未找到目标节点，还原路径 } if(root-&gt;right)//DFS非空右子树 { DFS(root-&gt;right,goal,road,HasFind); if(!HasFind) road.pop();//子树中未找到目标节点，还原路径 } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { DFS(root,p,P,PFlag); DFS(root,q,Q,QFlag); stack&lt;TreeNode*&gt;Proad,Qroad; while(!P.empty()) { Proad.push(P.top()); P.pop(); } while(!Q.empty()) { Qroad.push(Q.top()); Q.pop(); } P=Proad; Q=Qroad; int MAXSize=P.size(); if(MAXSize&lt;Q.size()) { MAXSize=Q.size(); } TreeNode* temp=root; while(1) { if(P.empty()||Q.empty()) break; if(P.top()==Q.top()) { temp=P.top(); P.pop(); Q.pop(); }else break; } return temp; } }; 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 写这个题的时候，额。。。没看树的类型，直接敲了树的DFS，其实可以利用二叉检索树的特性的，服了，算了，反正目的达到了。下回有机会再写吧。 非递归实现BFSLeetcode 127.解法. 题目给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。说明: 如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] 输出: 5 解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, 返回它的长度 5。示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] 输出: 0 解释: endWord “cog” 不在字典中，所以无法进行转换。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-ladder著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProcessOfEquivalentPair]]></title>
    <url>%2F2019%2F11%2F06%2FProcessOfEquivalentPair%2F</url>
    <content type="text"><![CDATA[连通区域标记－行程扫描算法— 等价对的处理过程将等价对转换为若干个等价序列,比如有如下等价对: 只要两个数在同一序偶中，就用线连起来，化成一棵树经过等价对处理之后,应得到的等价序列为: list1:1-2-5-6-8-10-11-12-13-14-15 list2:3-7-9 list3:4 主要思路:将1-15个点都看成图的节点,而等价对说明节点1和2之间有通路,而且形成的图是无向图.我们需要遍历图,找到其中的所有连通图,主要采用的是图的深度优先遍历法,进行等价序列的查找. 如上图所示,从节点1开始查找,它有三个路径1-2,1-6,1-8;2和6后面没有路径,8后面有两个路径8-10,8-11;10后面没有路径,11后面有5条路径分别为11-5,11-12,11-13,11-14,11-15,到此,等价表1查找完毕. 等价表2是从3开始查找,它的后面有两条路径3-7,3-9. 等价表3只有一个孤立的点. 并查集父节点表示法对于树中的每个结点都保存一个指针域指向父结点。（缺点：不能准确地找到给定的结点的子结点信息。优点：可以解决判断俩个结点是否在同一个树中的问题；用并查算法合并俩个集合。） 基本操作查询元素a和元素b是否属于同一组：由于采用父节点表示法，使用递归，一直向上检索，判断两个节点能否走到同一个根（查询是否有共同祖先祖先），即可知道是否在一组中。 在下图，2和5都走到了1，因此他们为同一组。另一方面，由于7走到的是6，因此与2和5属于不同组 合并元素a和元素b所在的组：像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树，也就是把两个组合并为了一个组。将其中一颗树的根节点作为另一颗树的子节点： 并查集实现中的注意点(优化)(降低rank）退化问题在树形数据结构中，如果发生了退化的情况，那么复杂度就会变得很高。因此有必要避免退化（呈线性，树形结构不明显，丧失树形优势）1.对于每棵树，记录这棵树的高度（rank）2.合并时如果两个数的rank不同，那么从rank小的向rank大的连边。（大的连在小rank树上，会在大rank基础上增加深度；小的连在大的上，就可能会被包含，并不增加rank） 路径压缩不论是所查询的节点，还是在查询过程中向上经过的其他所有节点，都直接改为直接连到根上。这样再次查询这些节点时，就可以很快知道根是谁了。（降低rank）]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BasicAlgorithm]]></title>
    <url>%2F2019%2F11%2F02%2FBasicAlgorithm%2F</url>
    <content type="text"><![CDATA[一些板子 一些基本算法位运算左移variable = variable &lt;&lt; numvariable &lt;&lt;=num观察可以发现，左移一位的结果就是原值乘2，左移两位的结果就是原值乘4。右移variable = variable &gt;&gt; numvariable &gt;&gt;=num右移一位的结果就是原值除2，左移两位的结果就是原值除4，注意，除了以后没有小数位的，都是取整。按位与：字面意思variable &amp; 1 -&gt; 拿到最低位的数字variable &amp; 00000001 -&gt;0000000a 快速积快速幂战神级讲解; a)欧几里德算法求最大公约数 实现一：#include &lt;iostream&gt; using namespace std; int gcd(int m, int n) { int r = 0; while(n!=0) { r=m%n; m=n; n=r; } return m; } int main() { int m,n; cout&lt;&lt;&quot;请输入2个正整数：&quot;&lt;&lt;endl; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;endl&lt;&lt;&quot;最大公约数为：&quot;&lt;&lt;gcd(m,n)&lt;&lt;endl; return 0; } 实现二：int gcd(int a,int b) {//b是上一层的余数 a%b是这一层的余数 a是除数 return b==0?a:(gcd(b,a%b)); } b)筛法求素数（朴素筛和快速线性筛）埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。为啥终止是根号n呢， 首先我们要明确，假设一个合数x能表示为两个数的乘积，他必定有一个小于等于sqrt(x)的因子，这可以用归谬证明法证明。如果两个因子都大于sqrt(x)，那么乘积大于x,这和假设矛盾。 然后就是，根据埃氏筛的思想，拿到当前序列的第一个新的素数，然后往后遍历筛选。因而对于序列较后面的数，在小于等于根号n的范围内总有机会被 其小于等于sqrt(x)的因子 筛一次（如果这个数真是合数的话），进而被筛去 大致过程：(1).把2到n的自然数放入a[2]到a[n]中(所放入的数与下标号相同) ; (2).在数组元素中以下标为序，按顺序找到未曾找过的最小素数minp和它的位置p(即下标号); (3).从p+1开始，把凡是能被minp整除的各元素值从a数组中划去(筛掉)，也就是把该元素标记为0;举个例子：minp=3 就把 3*3 3*4 3*5….筛掉，即PrimeFlag标记为0，is not a prime（也是缺点来源） 至于为什么从minp*minp开始筛:不需要从i*j（且j &lt; i）开始，因为i*j，在遇到j时已经被标记了，因为j比i小，所以遇到j比遇到i要早。同时因为从i*i开始标记，所以i终止条件也为sqrt(n)，否则i*i将大于n。（算是第二个方面限制i的范围在根号n内吧） (4).让p=p+1，重复执行第(2) (3)步骤，知道，minp&gt;floor(sqrt(n))为止; (5).打印输出a数组中留下来的数，未被筛掉的各元素值; int isPrime_sieve(int n){ int* isPrimes = (int*)malloc(sizeof(int)*(n+1)); int i,j; int sqrtn = sqrt(n); if(n&lt;=1) return 0; for(i=2;i&lt;=n;i++){ //初始化都为素数 isPrimes[i] = 1; } //从2开始，将素数的倍数标记为非素数 //从i的平方开始标记即可，不需要从i*j(且j&lt;i)开始，因为i*j至少在遇到j时已经被标记过了 for(i=2;i&lt;=sqrtn;i+=1){ if(isPrimes[i]==0) //不是素数，说明i可以分解为两个因子相乘，那么在遇到这两个因子的较小者时，i的倍数已经被标记过 continue; for(j=i*i;j&lt;=n;j+=i){ //j是i的倍数 isPrimes[j] = 0; } } return isPrimes[n]; } 这种求素数的算法很容易被理解，其时间复杂度介于O(n)~O(nlogn)是一种比较流行的方法。但是同样的，这种算法也存在先天性的缺陷，我们简单分析：对于一个数30，可分解为30=2*15=3*10=5*6，显然，当循环,2,3,5,6,10,15时都会筛除一次30这个数，而当n很大时，就会出现许多的冗余操作， 快速线性筛：(1).开一个n+1大小的数组num[]来存放每一个元素的筛留情况(num[i]用来表示i这个数是不是素数对于任意num[i] 有num[i]=0,num[i]=1两种情况，如果num[i]=0则是素数，反之num[i]=1时是合数); (2).再开一个数组prime[n]来存放筛出的素数以便最后输出结果; (3).对于一个数i,总是进行从i*prime[0]~i*prime[j](由小到大来乘)，直到if(i%prime[j]==0)成立时break掉 对（3）解释一下：第一，所有数（2~n）都会被作为i拿来判定，即第一层循环第二，为什么是从i*prime[0]~i*prime[j](由小到大来乘) 前提是：一个合数 i=p1*p2*…*pn, pi都是素数（2&lt;=i&lt;=n）,pi&lt;=pj ( i&lt;=j )p1是最小的系数。这样每一个合数就有一个确定的表示方法，不会重复。（像12=223）No.1：我们现在规定一个合数由两个数得到。NO.2：那么合数有两种。1.素数*素数=合数2.一个最小的素数*合数=合数 至于为什么if(i%prime[j]==0)成立时break掉 我们约定一下：记作 c*i而 c=a*b（b为c的最小质因数），按照结论，对于c这一组，只应当把i的值取到b因为假如取到了b+1 记为d=b+1, 则 迭代到 c*d而c=a*b 故 迭代到了 a*b*d 即 a*d*b -&gt; c’*b因而c*d==c’*b 这个数被多次判定 造成冗余 举个例子，对于一个数9，9*2=18将18标记为合数，循环继续；9*3=27将27标记为合数，此时发现9%3=0，循环退出。如果将循环继续下去会出现筛除9*5=45的情况，会对45进行一次筛选，而45=15*3，在15时会被在筛去一次，故不可行 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;ctime&gt; #include&lt;cmath&gt; #define inf 20000005 using namespace std; int n; bool a[inf+1]; bool num[inf+1]={1,1}; int prime[inf+1]={0},number=0; //number 记录素数个数 void putongshaifa() //普通筛法求素数 { clock_t begin,end; begin=clock(); for(int i=0;i&lt;=n;++i) a[i]=true; //初始化 全是素数 a[1]=false; //1不是素数 for(int i=2;i&lt;sqrt(n);++i) if(a[i])//新的第一个素数 for(int j=2;j&lt;=n/i;++j) a[i*j]=false; //i*1 i*2 i*3...一直往后筛 end=clock(); /*for(int i=2,t=0;i&lt;=n;++i) if(a[i]) { cout&lt;&lt;i&lt;&lt;&quot; &quot;; ++t; if(t%10==0) cout&lt;&lt;endl; } cout&lt;&lt;endl;*/ printf(&quot;普通筛法-Time used:%d ms\n&quot;,end-begin); return; } void kuaisushaifa() //快速筛法求素数 { clock_t begin,end; begin=clock(); for(int i=2;i&lt;=n;++i) //遍历所有2~n数 -&gt;i { if(!num[i]) prime[number++]=i; /*先用number的值再自加*/ for(int j=0;j&lt;number &amp;&amp; i*prime[j]&lt;=n;j++) { num[i*prime[j]]=1; //把所有合数标记为 1 if(!(i%prime[j]) /*i%prime[j]==0*/ ) // *为保证不重复筛选* break; } } end=clock(); /*for(int i=0;i&lt;number;i++) { if(i%10==0) printf(&quot;\n&quot;); printf(&quot;%3d&quot;,prime[i]); } */ printf(&quot;快速筛法-Time used:%d ms\n&quot;,end-begin); return; } int main() { //freopen(&quot;prime.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); int _test=10; while(_test--) { putongshaifa(); kuaisushaifa(); cout&lt;&lt;endl; } return 0; } #include&lt;iostream&gt; using namespace std; const int MAX=1000; bool IsPrime[MAX]; int Prime[MAX]; int main() { int n; cin&gt;&gt;n; int *a= new int[n+5]; for(int i=1;i&lt;=n;i++) { a[i]=i; IsPrime[i]=1; } int CurrPrime=0; IsPrime[1]=0; IsPrime[2]=1; for(int i=2;i&lt;=n;i++) { if(IsPrime[i]) { Prime[CurrPrime]=i; CurrPrime++; } for(int j=0;j&lt;CurrPrime&amp;&amp;i*Prime[j]&lt;=n;j++) { IsPrime[i*Prime[j]]=0; if(i%Prime[j]==0) { break; } } } for(int i=2;i&lt;=n;i++) { if(IsPrime[i]) { cout&lt;&lt;i&lt;&lt;&quot; is Prime\n&quot;; }else{ cout&lt;&lt;i&lt;&lt;&quot; is not a prime\n&quot;; } } return 0; } c)康托展开公式： rank = a_{n}\cdot(n-1)!+a_{n-1}\cdot(n-2)!+...+a_{1}\cdot 0!举例套用公式和理解：1,2,3,4的各个全排列按照字典序排列得到的rank 从0开始，即：（1234）的rank=0 其中，a_{i}的取值：先取在本排列中的第i位数字（最右边为第1位数字），在还未出现的元素中序列中，求出该数字的排名。 举个例子：（3214)\_{rank}= 2\*(4-1)!+1\*(4-2)!+0\*(4-3)!+0\*0!=14 设已经出现（或者说已经参与排列的元素）集合为S 初始化S={} 补集！S={1，2，3，4} 开始从给出的排列序列的最高位判断 3：处在3的位置，对应a_{3}的求解， 在！S中 元素3 大小排在第三位，a_{3}=3-1=2 （或者理解为！S中比3小的数字有2个） S={3} ！S={1，2，4} 2：处在2的位置，对应a_{2}的求解， 在！S中 元素2 大小排在第二位，a_{2}=2-1=1 （或者理解为！S中比2小的数字有1个） S={3，2} ！S={1，4} 1：处在1的位置，对应a_{1}的求解， 在！S中 元素1 大小排在第一位，a_{1}=1-1=0 （或者理解为！S中比1小的数字有0个） S={3，2，1} ！S={4} 4：处在0的位置，对应a_{0}的求解， 在！S中 元素4 大小排在第一位，a_{0}=1-1=0 （或者理解为！S中比4小的数字有0个） S={3，2，1，4} ！S={} 其实，最后一位的值不用判断总是取0，因为此时S中只会剩下这唯一一个元素 rank=14 最后，如果要求3214在全排列中排第几位，应当写 rank+1 = 15 d)逆康托展开辗转相除：（没有找到严谨的数学推理，先这样吧）还是上面的例子：3，2，1，4 rank=14 14 % (3!)=2...2 2 % (2!)=1...0 0 % (1!)=0...0 0 % (0!)=0...0 (最后一行同样不需要计算) 则还原过程： 初始化S={} 补集！S={1，2，3，4} 排名为2 +1：从！S中取出升序排列第3的数字：3 S={3} 补集！S={1，2，4} 排名为1 +1：从！S中取出升序排列第2的数字：2 S={3，2} 补集！S={1，4} 排名为0 +1：从！S中取出升序排列第1的数字：1 S={3，2，1} 补集！S={4} 排名为0 +1：从！S中取出升序排列第1的数字：4 S={3，2，1，4} 补集！S={} rank为14的序列为 3，2，1，4 e)同余定理两个整数除以同一个整数，若得相同余数，则二整数同余 数论中的一个重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，也读作a同余于b模m，记作a≡b(mod m)。对模m同余是整数的一个等价关系a=m*d+fb=m*e+f=&gt;(a-b)%m=(d-e)*m%m=d-e (假设a&gt;=b) 2019/11/7/21：32 to be continued… f)次方求模—快速幂(取模)算法对于普通类型的a_{n}求法是，自乘n次a 快速幂：1）当b是奇数时，那么有 a^{b}=a\cdot a^{b}2）当b是偶数时，那么有 a^{b}=a^{b/2}\cdot a^{b/2} 递归法：举个例子 2^{10}= (2^{\frac{10}{2}})^{2} 2^{5} = 2\cdot (2^{\frac{4}{2}})^{2}long long int binaryPow(long long int a, long long int b, long long int m){ if(b == 0) return 1; else if(b % 2 == 1) return a * binaryPow(a, b - 1, m) % m; else{ long long int num = binaryPow(a, b/2, m) % m; //优化 return num * num % m; // 不直接写成return binaryPow(a, b/2, m) * binaryPow(a, b/2, m) } } 迭代法：13=8*1+4*1+2*0+1*1 = 2^{3}*1+2^{2}*1+2^{1}*0+2^{0}*1 long long int binaryPow(long long int a, long long int b, long long int m){ long long int ans = 1; while(b &gt; 0){ if(b &amp; 1){//判断当前b的二进制位最低位 是否为1 从而提供乘的依据 ans = ans * a % m;//根据需要 是否乘2^{i} } a = a * a % m;//平方计数器 b &gt;&gt;= 1; //右移一位 } return ans; }]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearningPath]]></title>
    <url>%2F2019%2F11%2F02%2FLearningPath%2F</url>
    <content type="text"><![CDATA[临时路线. 需要掌握以下基本算法：a)欧几里德算法求最大公约数b)筛法求素数c)康托展开d)逆康托展开e)同余定理f)次方求模计算几何初步a)三角形面积b)三点顺序 学会简单计算程序的时间复杂度与空间复杂度二分查找法简单的排序算法a)冒泡排序法b)插入排序法贪心算法经典题目]]></content>
  </entry>
  <entry>
    <title><![CDATA[ShortestPath]]></title>
    <url>%2F2019%2F11%2F01%2FShortestPath%2F</url>
    <content type="text"><![CDATA[感慨：大一一年，奔波了不少地方，雨露均沾，我其实有些累了，团队合作开发一直是我所羡慕的，但是我一直没有做成一件项目，我理解大家都有各自的想法，我累了，我现在想自己走一走了临时路线. 最短路径：什么是最短路径？ 单源最短路径（所谓单源最短路径就是只指定一个顶点，最短路径是指其他顶点和这个顶点之间的路径的权值的最小值）什么是最短路径问题？ 给定一带权图，图中每条边的权值是非负的，代表着两顶点之间的距离。指定图中的一顶点为源点，找出源点到其它顶点的最短路径和其长度的问题，即是单源最短路径问题 非负这个条件很有意思，要是负数且形成环的话，你可以在这条路上不断刷。。。反正是负数 带权图的单源最短路径Floyd算法\Floyd-Warshall算法Floyd算法.有一说一，讲的可以ヾ(≧▽≦*)o简述一下：初始化图-&gt;加载各点的路径长（矩阵存储）-&gt;顺序引入新的中转点-&gt;遍历更新路径长的矩阵-&gt;继续引入继续更新 for(k=1;k&lt;=n;k++) {//迭代更新新的中转点 for(i=1;i&lt;=n;i++) {//两层循环 遍历更新 路径长度矩阵 的值 for(j=1;j&lt;=n;j++) { if(e[i][j]&gt;e[i][k]+e[k][j]) { e[i][j]=e[i][k]+e[k][j]; } } } } Dijkstra算法该算法使用的是贪心策略：每次都找出剩余顶点中与源点距离最近的一个顶点。参考：Dijkstra算法 算法思想带权图G=令S为已确定了最短路径顶点的集合，则可用V-S(V集合减去S集合)表示剩余未确定最短路径顶点的集合。假设V0是源点，则初始 S={V0}。用数组Distance表示源点V0到其余顶点的路径长度，用数组pre[i]表示最短路径序列上顶点i的前一个顶点。初始时，pre[i]都是源点的下标。接下来需重复两个步骤： 从当前Distance[i]找出最小的一个，记录其下标v=i，源点V0到顶点Vv的最短路径即已确定，把Vv加入S。更新源点到剩余顶点的最短路径长度。更新方法是：以上一步的顶点Vv为中间点，若Distance[v]+weight(v,i)小于Distance[i]，则修改值：pre[i]=v;Distance[i]=Distance[v]+weight(v,i);重复以上两个步骤，直至所有顶点的最短路径都已找到.。需要指出，Dijkstra算法求解的不仅是有向图，无向图也是可以的。下面给出一个完整的有向带权图的实例： SPFA算法\Bellman-Ford算法Johnson算法A*算法]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaxHeap]]></title>
    <url>%2F2019%2F11%2F01%2FGensokyo%2F</url>
    <content type="text"><![CDATA[不是我变化太大，只是预见了最后的可能分支。为了不被抛弃，更为了避免那时的无能狂怒，我只能选择，不辞而别，独自行走。 最大堆和最小堆最大堆和最小堆是二叉堆的两种形式。（完全二叉树） 最大堆：根结点的键值是所有堆结点键值中最大者，且每个结点的值都比其孩子的值大。 最小堆：根结点的键值是所有堆结点键值中最小者，且每个结点的值都比其孩子的值小。构建方式不唯一 下面对书本上的bulid过程分析并实现：（仅仅分析最大堆，则最小堆可以重载大于号等进行构建） 关键操作：siftdown(节点下沉、下拉) 构建的算法原理基础：归纳证明假设根的两个子树都是最大堆了，设根的元素为R，则有两种情况：一、R的值大于或者等于其两个子节点，此时最大堆结构完成二、否则，R与两个子节点中大的那一个交换位置，此时最大堆结构完成，或者重复第二步直到完成 为了使得子树已经是最大堆，则可以采用递归（我们不用），或者倒着循环上来下面采用循环实现BuildHeap： 初始化curr=HeapSize/2（最后一个分支节点，开始开倒车） BuildMaxHeap#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int a[1000]; void OrderPrint(int n) { int line=2; for(int i=1;i&lt;=n;i++) { cout&lt;&lt;&#39; &#39;&lt;&lt;a[i]&lt;&lt;&#39; &#39;; if(i==line-1) {// 1 3 7 cout&lt;&lt;endl; line*=2; } } } int main() { int n; cin&gt;&gt;n; memset(a,0,1000*sizeof(int)); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } int HeapSize=n; for(int curr=HeapSize/2;curr&gt;=1;curr--) { int son=curr*2;//son 其实可以理解为 变动元素的下一个待判断的位置 //a[0]=a[curr]; while(son&lt;=HeapSize)// //待判断的位置 的 上限 { if(a[son]&lt;a[son+1]) { son++; } if(a[son/2]&gt;=a[son]) {/*父节点大于最大子节点 堆结构 构造完成*/ break;//停止下沉 } else{//节点小于最大子节点 swap(a[son/2],a[son]);//父变子 子变父 son*=2;//待判断的位置 移动到下一层 } } } OrderPrint(HeapSize); return 0; } 插入：添加到数组尾部（n+1处）比较简单和其父节点比较一路 上浮 到合适的位置即可可以调用OrderPrint方法查看上浮全程（其实我拿来debug的，因为我这a[0]的元素会干扰，a[0]并非堆中的节点） void MaxHeapInsert(int element,int &amp; HeapSize) { HeapSize++; a[HeapSize]=element; int curr=HeapSize; while(curr/2&gt;0&amp;&amp;a[curr/2]&lt;a[curr]) { //OrderPrint(HeapSize); swap(a[curr/2],a[curr]); curr/=2;//节点上浮 //OrderPrint(HeapSize); } } 删除：最大堆的删除，只能删除堆的最大值（根节点）把最后一个元素移动到根节点来当老大，然后siftdown对堆重排 不写了，&lt;(*\￣▽￣*)/]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pythonLearning]]></title>
    <url>%2F2019%2F10%2F27%2FpythonLearning%2F</url>
    <content type="text"><![CDATA[为了看懂Microsoft Speech Services API的源码，学习一下python的语法 python raise当程序出现错误，python会自动引发异常，也可以通过raise显示地引发异常。一旦执行了raise语句，raise后面的语句将不能执行 s = None if s is None: raise NameError print &#39;is here?&#39; 直接抛出异常，不会执行到这里 python 继承子类直接 son(farther) class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return &#39;Father &#39; + self.name class Son(Father): def getName(self): return &#39;Son &#39;+self.name str方法如果要把一个类的实例变成 str，就需要实现特殊方法str()：例子： 不使用str()方法class Student(object): def __init__(self,id,name,age): self.id=id self.name=name self.age=age s=Student(111,”Bob”,18)print(s)输出结果： main.Student object at 0x0362EBF0 使用str()方法class Student(object): def __init__(self,id,name,age): self.id=id self.name=name self.age=age def __str__(self): return &quot;学号:{}--姓名:{}--年龄{}&quot;.format(self.id,self.name,self.age) s=Student(111,”Bob”,18)print(s)输出结果：学号:111–姓名:Bob–年龄18 Python中的format方法类似printf()中的占位符print(“{}的性别是：{}”.format(“小明”,”男”))输出结果：小明的性别是：男 Python中的self指向类实例化后的对象，自己 Python中*args**kargs的用法总结先看一下固定参数的函数两输入加法函数def sum(x, y): z = x + y return zprint(sum(1,2)) 可变位置参数：*args 列表python中规定参数前带* 的，称为可变位置参数，只是我们通常称这个可变位置参数为*args,习惯和规范而已*args：是一个列表，传入的参数会被放进列表里。（c++建工程时创建的main函数的参数似乎也有，不太记得了，好像是用来接入命令行中的输入数据的，和这个有些类似，下回想起来了再说吧） def sum(\*args): ans = 0 for i in args: ans = ans + i print(ans) sum(1, 3, 5) 计算过程：ans=1+3+5 可变关键字参数：**kwargs 键值对同理，python中规定参数前 带 ** 的，称为可变关键字参数，通常用**kwargs表示。**kwargs：是一个字典，传入的参数以键值对的形式存放到字典里。 def test(**kwargs): print(kwargs) test(a=1,b=2,c=3) 运行结果：{‘a’: 1, ‘b’: 2, ‘c’: 3}]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicrosoftAPIReadingNotes]]></title>
    <url>%2F2019%2F10%2F27%2FMicrosoftAPIReadingNotes%2F</url>
    <content type="text"><![CDATA[azure-cognitiveservices-speech reference. 短促的字段识别（15s）start_continuous_recognition()]]></content>
      <tags>
        <tag>Microsoft Speech Services API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[step4-NonLinearRegression]]></title>
    <url>%2F2019%2F10%2F09%2Fstep4%2F</url>
    <content type="text"><![CDATA[https//www.codecogs.com/latex/eqneditor.php在线LaTeX公式编辑器 Step4 转载于Microsoft/ai-edu/blob/master/B-教学案例与实践最近赶进度，就不更了，有时间会把自己做的思考与练习题放在这里。 前向计算：输入 处理 输出误差计算：loss = predict - table反向传播|梯度下降 调整参数: 链式求导法则 9.3 双层神经网络实现非线性回归9.3.1 万能近似定理两层前馈神经网络（即一个隐层加一个输出层）和至少一层具有任何一种挤压性质的激活函数，只要隐层的神经元的数量足够，它可以以任意的精度来近似任何从一个有限维空间到另一个有限维空间的Borel可测函数。当然这个函数需要是单调递增有界的。注意，它要求的是挤压性质的激活函数，也就是类似Sigmoid的函数，如果用ReLU函数不能实现这个效果9.3.2 定义神经网络结构 输入层：一个标量X（自变量）输入层-隐藏层之间： 权重矩阵W1/B1 — 1行3列 W1= \begin{pmatrix} w^1_{11} & w^1_{12} & w^1_{13} \end{pmatrix} B1= \begin{pmatrix} b^1_{1} & b^1_{2} & b^1_{3} \end{pmatrix}隐层我们用3个神经元： Z1 = \begin{pmatrix} z^1_1 & z^1_2 & z^1_3 \end{pmatrix} A1 = \begin{pmatrix} a^1_1 & a^1_2 & a^1_3 \end{pmatrix}权重矩阵W2/B2W2的尺寸是3x1，B2的尺寸是1x1。 W2= \begin{pmatrix} w^2_{11} \\ w^2_{21} \\ w^2_{31} \end{pmatrix} B2= \begin{pmatrix} b^2_{1} \end{pmatrix}输出层由于我们只想完成一个拟合任务，所以输出层只有一个神经元：仅需得到一个因变量（Y） Z2 = \begin{pmatrix} z^2_{1} \end{pmatrix}9.3.3 前向计算隐层 线性计算 z^1_{1} = x \cdot w^1_{11} + b^1_{1} z^1_{2} = x \cdot w^1_{12} + b^1_{2} z^1_{3} = x \cdot w^1_{13} + b^1_{3} Z1 = X \cdot W1 + B1 \tag{1} 激活函数 a^1_{1} = Sigmoid(z^1_{1}) a^1_{2} = Sigmoid(z^1_{2}) a^1_{3} = Sigmoid(z^1_{3}) A1 = Sigmoid(Z1) \tag{2}输出层由于我们只想完成一个拟合任务，所以输出层只有一个神经元： z=a^1_{1}w^2_{11}+a^1_{2}w^2_{21}+a^1_{3}w^2_{31}+b^2_{1}矩阵形式： Z=A1 \cdot W2+B2 \tag{3}损失函数均方差损失函数： loss(w,b) = \frac{1}{2} (z-y)^2 \tag{4}s其中，$z$是样本预测值，$y$是样本的标签值，这里的z是第二层的输出Z。 回忆之前的简单模型，输入-&gt;单层神经元处理（线性计算+sigmoid）-&gt;输出Z1和Z 如果从局部来看，都是输出。只是Z1经过sigmoid处理后得到A再作为下一层的输入如下图|本章的神经网络|||第5章的神经网络||| 根据公式4： {\partial loss \over \partial z} = z - y \tag{5}求W2的梯度根据公式3和W2的矩阵形状： dW2={\partial loss \over \partial W2} = \begin{pmatrix} {\partial loss \over \partial z}{\partial z \over \partial w^2_{11}} \\ \\ {\partial loss \over \partial z}{\partial z \over \partial w^2_{21}} \\ \\ {\partial loss \over \partial z}{\partial z \over \partial w^2_{31}} \end{pmatrix} = \begin{pmatrix} (z-y) \cdot a^1_{1} \\ (z-y) \cdot a^1_{2} \\ (z-y) \cdot a^1_{3} \end{pmatrix} =\begin{pmatrix} a^1_{1} & a^1_{2} & a^1_{3} \end{pmatrix}^T(z-y) =A1^T(Z-Y) \tag{6}求B2的梯度 dB2={\partial loss \over \partial B2}=z-y \tag{7}|反向传播| 根据公式3和A1矩阵的形状： {\partial loss \over \partial A1} = \begin{pmatrix} {\partial loss \over \partial Z}{\partial Z \over \partial a_{11}} & {\partial loss \over \partial Z}{\partial Z \over \partial a_{12}} & {\partial loss \over \partial Z}{\partial Z \over \partial a_{13}} \end{pmatrix} = \begin{pmatrix} (z-y)w^2_{11} & (z-y)w^2_{12} & (z-y)w^2_{13} \end{pmatrix} =(z-y) \begin{pmatrix} w^2_{11} & w^2_{21} & w^2_{31} \end{pmatrix} =(z-y) \begin{pmatrix} w^2_{11} \\ w^2_{21} \\ w^2_{31} \end{pmatrix}^T=(Z-Y) \cdot W2^T \tag{8}现在来看激活函数的误差传播问题，由于公式2$A1=sigmoid(Z1)$在计算时，并没有改变矩阵的形状，相当于做了一个矩阵内逐元素的的计算，所以它的导数也应该是逐元素的计算，不改变误差矩阵的形状。根据Sigmoid激活函数的导数公式，有： {\partial A1 \over \partial Z1}=A1 \odot (1-A1) => dA1 \tag{9}所以最后到达Z1的误差矩阵是： {\partial loss \over \partial Z1}={\partial loss \over \partial Z}{\partial Z \over \partial A1}{\partial A1 \over \partial Z1} =(Z-Y) \cdot W2^T \odot dA1 => dZ1 \tag{10}有了dZ1后，再向前求W1和B1的误差，就和第5章中一样了，我们直接列在下面： dW1=X^T \cdot dZ1 \tag{11} dB1=dZ1 \tag{12}在学习MachineLearning的时候，我最烦恼的事情就是矩阵相乘时候的尺寸，和是否转置。这些操作主要是为了通过矩阵相乘，来进行批量预算，故而需要适时地通过转置调整尺寸例如这里的X矩阵，为第一层的输入，它的原始形状为（特征1， 特征2， 特征3）1行-3列这是样本一的三个特征输入，而权重矩阵是3行-1列，故用于对权重矩阵进行数值调节的dW矩阵应当与权重矩阵一致，即3行-1列，此处对X矩阵转置为3行-1列再乘上一个标量z-y 对于之前学过的两输入一输出的单神经元模型有：Z=w0(即b)+w1x1+w2x2（x为特征值）A=sigmoid(Z) [如果需要的话，先不讨论] dW1=X^T \cdot dZ1 \tag{11} dB1=dZ1 \tag{12}显然成立 而本节所讲的加入隐藏层所构成的神经网络，可以看成是两个简单过程的拼接 输入 处理 输出（第一层输出作为输入）输入 处理 输出]]></content>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maxim_Go]]></title>
    <url>%2F2019%2F10%2F08%2FMaxim-Go%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
</search>
