<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode_for_offer47]]></title>
    <url>%2F2021%2F03%2F16%2FLeetcode-for-offer47%2F</url>
    <content type="text"><![CDATA[剑指Offer47.礼物的最大值在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 来源：力扣（LeetCode）链接：礼物的最大值.著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 dfs暴力搜索，$O(2^{n})$ dp动态规划，$O(N*M)$ dfs 1234567891011121314151617int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int M,int N,int r,int c,int sum)&#123; //edge test if(r==M-1&amp;&amp;c==N-1)&#123; return sum+grid[r][c]; &#125; if(c==N-1)return dfs(grid,M,N,r+1,c,sum+grid[r][c]); else if(r==M-1)return dfs(grid,M,N,r,c+1,sum+grid[r][c]); else&#123; return max(dfs(grid,M,N,r+1,c,sum+grid[r][c]) ,dfs(grid,M,N,r,c+1,sum+grid[r][c]) ); &#125; &#125; int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int M=grid.size(); int N=grid[0].size(); return dfs(grid,M,N,0,0,0); &#125; dp 状态转移方程：$dpTable[i][j]=max{dpTable[i-1][j],dpTable[i][j-1]}+mat[i][j]$ 分析：dpTable[i][j]的最优解总是从两个子问题最优解的较大者转移而来12345678910111213141516171819202122const static int MAX_M=200; const static int MAX_N=200; int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int M=grid.size(); int N=grid[0].size(); int dpTable[MAX_M][MAX_N]; //dpTable[i][j]=max&#123;dpTable[i-1][j],dpTable[i][j-1]&#125;+mat[i][j] memset(dpTable,0,MAX_M*MAX_N*sizeof(int)); //init the edge of table dpTable[0][0]=grid[0][0]; for(int i=1;i&lt;M;i++)dpTable[i][0]=grid[i][0]+dpTable[i-1][0]; for(int i=1;i&lt;N;i++)dpTable[0][i]=grid[0][i]+dpTable[0][i-1]; for(int i=1;i&lt;M;i++)&#123; for(int j=1;j&lt;N;j++)&#123; dpTable[i][j]=grid[i][j]+max(dpTable[i-1][j] ,dpTable[i][j-1]); &#125; &#125; return dpTable[M-1][N-1]; &#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode565]]></title>
    <url>%2F2021%2F03%2F15%2FLeetcode565%2F</url>
    <content type="text"><![CDATA[667.数组嵌套数组嵌套.题目描述：索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], … }且遵守规则：假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]… 以此类推，不断添加直到S出现重复的元素。 解法 暴力枚举 复杂度$O(N^{2})$12345678910111213141516171819int arrayNesting(vector&lt;int&gt;&amp; nums) &#123; int N=nums.size(); int res=0; for(int i=0;i&lt;N;i++)&#123; memset(vis,0,MAX_N*sizeof(bool)); //S[i] int leftNum=nums[i];//init first postion: A[i] for(int j=0;j&lt;=N;j++)&#123; if(!vis[leftNum]) vis[leftNum]=true; else&#123;//end, length&lt;-i if(res&lt;j)res=j; break; &#125; leftNum=nums[leftNum]; &#125; &#125; return res; &#125; 图论$O(n)$注意到以下几点： 嵌套关系可以抽象成有向边 基于第一点，以数组元素$A[i]$为一个结点，则图中每个节点出度、入度均为1。(对于$A[i]$，入结点和出结点分别为$A[j]=i,A[k]=A[A[i]]$) 综上可以看出： 集合S由图中一个环上的结点元素值组成 且由于图中每个节点的出度、入度均为1，则每个节点仅处于一个环上1234567891011121314151617181920212223242526int MAX_N=20005; bool vis[20005]; int arrayNesting(vector&lt;int&gt;&amp; nums) &#123; int N=nums.size(); int res=0; memset(vis,0,MAX_N*sizeof(bool)); int pos=0;//the latest start point while(pos&lt;N)&#123; while(pos&lt;N)&#123; if(!vis[nums[pos]])break; ++pos; &#125; if(pos&gt;=N)break; //S[pos]=&#123;A[pos],A[A[pos]]&#125;... int leftNum=nums[pos]; int len=0; while(vis[leftNum]==false)&#123; vis[leftNum]=true; leftNum=nums[leftNum]; ++len; &#125; if(res&lt;len)res=len; &#125; return res; &#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UserCF-itemCF]]></title>
    <url>%2F2021%2F03%2F09%2FUserCF-itemCF%2F</url>
    <content type="text"><![CDATA[基于领域的推荐算法：分为两大类，一类是基于用户的协同过滤算法，一类是基于物品的协同过滤算法。核心：聚类、匹配相似的人/相似的物品 算法介绍 基于用户的协同过滤算法(userCF)： 步骤一：找到和目标用户相似的用户集合 步骤二：将该集合中用户喜欢的物品，推荐给目标用户 思想：目标用户与其相似用户的兴趣类似 基于物品(标的物)的协同过滤算法(itemCF)： 步骤一：计算物品之间相似度 步骤二：分析目标用户的历史行为，为其推荐与喜欢物品相似的其他物品 思想：目标用户曾经对物品A感兴趣，而物品B与A相似，则认为用户也会对B感兴趣 实验DEMO 数据集：MovieLens 1M Dataset、 概述：包含6000多用户对4000多部电影的100万条评分 数据格式： User：UserID::Gender::Age::Occupation::Zip-code MOVIES：MovieID::Title::Genres RATINGS：UserID::MovieID::Rating::Timestamp 数据读取： 12345userfile=open("D:/SIT/推荐系统/ml-1m/ml-1m/users.dat")for line in userfile.readlines(): line=line.strip("\n") print(line.split("::"))userfile.close(); 1234[&apos;1&apos;, &apos;F&apos;, &apos;1&apos;, &apos;10&apos;, &apos;48067&apos;][&apos;2&apos;, &apos;M&apos;, &apos;56&apos;, &apos;16&apos;, &apos;70072&apos;][&apos;3&apos;, &apos;M&apos;, &apos;25&apos;, &apos;15&apos;, &apos;55117&apos;].... 预处理： 数据集切分：将数据集随机切分为M份，取其中一份为测试集，剩下的M-1份为训练集。 代码： 1 结果： 1 算法评测 对用户$u$推荐N个物品，(记为$R(u)$)，令用户$u$在测试集上喜欢的物品集合为$T(u)$ 召回率： Recall=\frac{\sum_{u\in U}|R(u)\cap T(u)|}{\sum_{u\in U} |T(u)|} 准确率： Precision=\frac{\sum_{u\in U}|R(u)\cap T(u)|}{\sum_{u\in U} |R(u)|} 覆盖率：所有用户的推荐结果并集的元素个数除以总物品数，用以说明推荐结果列表可以包含多大比例的物品（一个推荐系统不能总是推荐一小部分商品。对于该指标随机推荐可以达到100%，因为每个物品有均等机会被推荐） Coverage=\frac{|\cup_{u\in U}R(u)|}{|I|} 新颖度：推荐结果列表的平均流行度]]></content>
      <tags>
        <tag>RecSys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode667]]></title>
    <url>%2F2021%2F03%2F09%2FLeetcode%20667%2F</url>
    <content type="text"><![CDATA[667.优美的排列II被围绕的区域.题目描述：给定整数n和k，需要返回一个长度为n的数组，该数组的元素为1-n的一个排列。对于该数组需要满足条件：对于数组$[a_{1},a_{2}…a_{n}]$，那么有集合$S={|a_{k}-a_{k+1}| |k\in [1,n-1]}$且 |S|=k 。 举例：输入：n=15,k=3输出：[1,4,2,3,5,6,7,8,9,10,11,12,13,14,15] 分析：返回的答案序列由两部分组成 第一部分：偶数下标对应的序列$[1,2,…\frac{k}{2}]$，奇数下标对应的序列$[k+1,k,…\frac{k}{2}]$,例子中：偶数下标的数字序列为[1,2,3],奇数下标的数字序列为[4] 第二部分：[k+2,k+3,…,n] 边界计算：偶数下标对应的序列为递增序列，奇数下标序列为递减序列，求出二者的交点数值(在$\frac{k}{2}$附近)。 如果k%2==0,交点处附近的数字为$…,\frac{k}{2},\frac{k}{2} +2,\frac{k}{2} +1,k+2,k+3…$ 如果k%2==1,交点处附近的数字为$…,\frac{k+1}{2},\frac{k+1}{2} +1,k+2,k+3…$123456789101112131415161718192021222324int* constructArray(int n, int k, int* returnSize)&#123; *returnSize=n;//返回数组大小 int *res=(int *)malloc(n * sizeof(int));//分配空间 for(int i=0;i&lt;n;i++)res[i]=i+1; if(k==1)return res;//k为1直接返回 int endIdx=0;//Res序列前一段的末尾下标 int beginIdx=0;//Res序列后一段的开始下标 if(k%2==0)&#123; endIdx=2*(k/2-1); res[endIdx+2]=k/2+1; beginIdx=endIdx+3; &#125;else&#123; endIdx=2*((k+1)/2-1); beginIdx=endIdx+2; &#125; for(int i=0;i&lt;=endIdx;i+=2)&#123; res[i]=i/2+1; res[i+1]=k+1-(res[i]-1); &#125; for(int i=beginIdx;i&lt;n;i++)&#123; res[i]=k+2+(i-beginIdx); &#125; return res;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TalkingPiano]]></title>
    <url>%2F2020%2F02%2F07%2FTalkingPiano%2F</url>
    <content type="text"><![CDATA[因为新型肺炎疫情，困于火炉旁的我的“胡思乱想” 二.钢琴瀑布流 弹出汉字在线钢琴模拟莫得钢琴的程序员：声明一下 我没系统学习过Python,所以有比较浓的C/C++风格（语法全靠查一个记一个） 先介绍下核心思路（其实十分简单，从构思到实现1.0版本，可能也就一个小时不到的亚子）： 得到汉字点阵，转化成二维数组，得到图片像素点的信息，方便做按键映射（知道什么时候敲下哪个按键） 完成键盘的键值对（类似ASCII码和字母）数组的构建，模拟敲击键盘（要不然人的手可敲不来）键盘各键对应键值 上面网站钢琴按键的瀑布流，可以用按下的时间长度来控制其形状，若比较短促，则可以形成矩形像素点（也是实现思路的来源，1.0版本的小Bug也是因为此） 1.0版本：准备工作： 生成汉字图像，当然你下载一个汉字图片也是可以的，只是尺寸可能就不那么统一了，得做一些规范化操作之类的 #encoding: utf-8 这个轮子来自博客https://blog.csdn.net/johinieli/article/details/76151247 import os import pygame chinese_dir = &#39;chinese&#39;#存储图片的文件夹名字 if not os.path.exists(chinese_dir): os.mkdir(chinese_dir) pygame.init() def produceCharacter(codepoint): word = chr(codepoint) # 将Unicode的值转换成对应字符 unichr()用不了 了？？ font = pygame.font.Font(&quot;msyh.ttc&quot;, 64)#复制找到的微软雅黑字体文件到工程文件夹即可 rtext = font.render(word, True, (0, 0, 0), (255, 255, 255)) pygame.image.save(rtext, os.path.join(chinese_dir, word + &quot;.png&quot;)) #湖，北，加，油的Unicode 16进制码 codepoint=[0x6E56,0x5317,0x52A0,0x6CB9] for code in codepoint: produceCharacter(code) 转化成二维数组，这里用到了一个图片二值化的操作即：将图片转化为黑白图片，且是非黑即白，所以称为二值。黑：0 白：255 光亮度，这样可以丢弃颜色细节，方便映射到钢琴按键的按与不按两种状态这样就可以完成对应，判断某一个像素点的位置，是否有黑色像素点，有的话就使用瀑布流做拟合先来看一下所谓的二值化操作效果图： threshold = 200 #用于对汉字图片进行简单二值化的阈值设置，小于则认为是黑色，大于则认为是白色 imgfile=[&quot;湖.png&quot;,&quot;北.png&quot;,&quot;加.png&quot;,&quot;油.png&quot;] for k in range(0,len(imgfile)): img = Image.open(imgfile[k]).convert(&#39;L&#39;)#调用函数，汉字图片转成灰度图 a_img = np.asarray(img,dtype=&quot;int64&quot;).copy()#调用函数，得到灰度图的像素矩阵 for i in range(0, a_img.shape[0]):#得到灰度图的像素矩阵，实际上取值为0-255 for j in range(0, a_img.shape[1]): print(0 if a_img[i][j] &lt; threshold else 1, end=&quot;&quot;)#二值化打印，未作实际的二值化 print() plt.imshow(img, cmap=&#39;gray&#39;)#展示汉字灰度图 plt.axis(&#39;off&#39;)#去除plt展示图像时所画的坐标轴 plt.show() 键盘的键值对（类似ASCII码和字母）数组的构建，方便代码控制，模拟敲击网站的钢琴按键映射的方案，就随意了，反正最后可以一一对应到一个个像素点就好，核心还是用短促的瀑布流图像，来模拟像素点关键字搜索：键盘键值对，或者上面有个百度文库的网址另外一点：Python有自己的键盘事件库，但是我调用的时候出现了一些问题，未能解决，就没采用了 tune = np.array([ 192, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 189, 187, 8, 81, 87, 69, 82, 84, 89, 85, 73, 79, 80, 219, 221, 220, 65, 83, 68, 70, 71, 72, 74, 75, 76, 186, 222, 90, 88, 67, 86, 66, 78, 77, 188, 190, 191, 32, 38, 37, 40, 39, 111, 106, 109, 103, 104, 105, 107, 100, 101, 102, 97, ], dtype=&quot;int64&quot;) 1.0版本代码遍历a_img二维数组，由于我们采取的是从下往上滚动汉字。所以进行自上而下，从左到右的遍历方式，外层循环按行遍历，内层按照列遍历（将屏幕倾斜90度，采用从左往右滚动汉字的话，类似） for i in range(0,a_img.shape[0]): for j in range(0,a_img.shape[1]): if a_img[i][j] &lt; threshold:#如果像素点为黑色，按下按键，由瀑布流产生‘像素点’ press(tune[j]) #end if #end for time.sleep(0.08)#按住一排需要按下的位置，持续一个较短时间 for j in range(0, a_img.shape[1]): if a_img[i][j] &lt; threshold:#松开刚才按下的所有按键 up(tune[j]) # end if # end for # end for time.sleep(1.5) 这里看一下运行的效果图： 可以看到，有一些缝隙，这就是我所说的1.0 的Bug 1.0bug修复-&gt;2.0版本 for i in range(0,a_img.shape[0]): for j in range(0,a_img.shape[1]): if a_img[i][j] &lt; threshold: press(tune[j]) #end if #end for time.sleep(0.08) if(i+1&lt;a_img.shape[0]):#判断下一行 for j in range(0, a_img.shape[1]): if a_img[i+1][j] &gt; threshold:#如果下一行该位置的值对应白色 up(tune[j])#则不需要像素点拟合，松开按键 # end if 否则该处的按键不松开，则会形成长条状的瀑布流图像 # end for # end if # end for bug出现的原因，猜测为，key_press和up函数需要较短时间来执行，当执行多次时，会有一定时间差，导致缝隙 完整代码 import matplotlib.pyplot as plt import numpy as np from PIL import Image import win32api import win32con import win32gui from ctypes import * import time def up(x): win32api.keybd_event(x, 0, win32con.KEYEVENTF_KEYUP, 0) def press(x): win32api.keybd_event(x, 0, 0, 0) tune = np.array([ 192, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 189, 187, 8, 81, 87, 69, 82, 84, 89, 85, 73, 79, 80, 219, 221, 220, 65, 83, 68, 70, 71, 72, 74, 75, 76, 186, 222, 90, 88, 67, 86, 66, 78, 77, 188, 190, 191, 32, 38, 37, 40, 39, 111, 106, 109, 103, 104, 105, 107, 100, 101, 102, 97, ], dtype=&quot;int64&quot;) time.sleep(2) threshold = 200 imgfile=[&quot;湖.png&quot;,&quot;北.png&quot;,&quot;加.png&quot;,&quot;油.png&quot;] for k in range(0,len(imgfile)): img = Image.open(imgfile[k]).convert(&#39;L&#39;) a_img = np.asarray(img,dtype=&quot;int64&quot;).copy() for i in range(0, a_img.shape[0]): for j in range(0, a_img.shape[1]): print(0 if a_img[i][j] &lt; threshold else 1, end=&quot;&quot;) print() plt.imshow(img, cmap=&#39;gray&#39;) plt.axis(&#39;off&#39;) plt.show() for i in range(0,a_img.shape[0]): for j in range(0,a_img.shape[1]): if a_img[i][j] &lt; threshold: press(tune[j]) #end if #end for time.sleep(0.08) if(i+1&lt;a_img.shape[0]):#判断下一行 for j in range(0, a_img.shape[1]): if a_img[i+1][j] &gt; threshold: up(tune[j]) # end if # end for # end if # end for time.sleep(150)#这里150s只是为了方便看一个汉字的运行情况,实际上两个汉字间隔1.5s左右即可 #end for &#39;&#39;&#39; 图像打印操作 和 键盘键值对 for i in range(0, a_img.shape[0]): for j in range(0, a_img.shape[1]): print(a_img\[i][j],end=&quot;&quot;) print() plt.imshow(img, cmap=&#39;gray&#39;) plt.axis(&#39;off&#39;) plt.show() VK_CODE = { &#39;backspace&#39;: 0x08, &#39;tab&#39;: 0x09, &#39;clear&#39;: 0x0C, &#39;enter&#39;: 0x0D, &#39;shift&#39;: 0x10, &#39;ctrl&#39;: 0x11, &#39;alt&#39;: 0x12, &#39;pause&#39;: 0x13, &#39;caps_lock&#39;: 0x14, &#39;esc&#39;: 0x1B, &#39;spacebar&#39;: 0x20, &#39;page_up&#39;: 0x21, &#39;page_down&#39;: 0x22, &#39;end&#39;: 0x23, &#39;home&#39;: 0x24, &#39;left_arrow&#39;: 0x25, &#39;up_arrow&#39;: 0x26, &#39;right_arrow&#39;: 0x27, &#39;down_arrow&#39;: 0x28, &#39;select&#39;: 0x29, &#39;print&#39;: 0x2A, &#39;execute&#39;: 0x2B, &#39;print_screen&#39;: 0x2C, &#39;ins&#39;: 0x2D, &#39;del&#39;: 0x2E, &#39;help&#39;: 0x2F, &#39;0&#39;: 0x30, &#39;1&#39;: 0x31, &#39;2&#39;: 0x32, &#39;3&#39;: 0x33, &#39;4&#39;: 0x34, &#39;5&#39;: 0x35, &#39;6&#39;: 0x36, &#39;7&#39;: 0x37, &#39;8&#39;: 0x38, &#39;9&#39;: 0x39, &#39;a&#39;: 0x41, &#39;b&#39;: 0x42, &#39;c&#39;: 0x43, &#39;d&#39;: 0x44, &#39;e&#39;: 0x45, &#39;f&#39;: 0x46, &#39;g&#39;: 0x47, &#39;h&#39;: 0x48, &#39;i&#39;: 0x49, &#39;j&#39;: 0x4A, &#39;k&#39;: 0x4B, &#39;l&#39;: 0x4C, &#39;m&#39;: 0x4D, &#39;n&#39;: 0x4E, &#39;o&#39;: 0x4F, &#39;p&#39;: 0x50, &#39;q&#39;: 0x51, &#39;r&#39;: 0x52, &#39;s&#39;: 0x53, &#39;t&#39;: 0x54, &#39;u&#39;: 0x55, &#39;v&#39;: 0x56, &#39;w&#39;: 0x57, &#39;x&#39;: 0x58, &#39;y&#39;: 0x59, &#39;z&#39;: 0x5A, &#39;numpad_0&#39;: 0x60, &#39;numpad_1&#39;: 0x61, &#39;numpad_2&#39;: 0x62, &#39;numpad_3&#39;: 0x63, &#39;numpad_4&#39;: 0x64, &#39;numpad_5&#39;: 0x65, &#39;numpad_6&#39;: 0x66, &#39;numpad_7&#39;: 0x67, &#39;numpad_8&#39;: 0x68, &#39;numpad_9&#39;: 0x69, &#39;multiply_key&#39;: 0x6A, &#39;add_key&#39;: 0x6B, &#39;separator_key&#39;: 0x6C, &#39;subtract_key&#39;: 0x6D, &#39;decimal_key&#39;: 0x6E, &#39;divide_key&#39;: 0x6F, &#39;F1&#39;: 0x70, &#39;F2&#39;: 0x71, &#39;F3&#39;: 0x72, &#39;F4&#39;: 0x73, &#39;F5&#39;: 0x74, &#39;F6&#39;: 0x75, &#39;F7&#39;: 0x76, &#39;F8&#39;: 0x77, &#39;F9&#39;: 0x78, &#39;F10&#39;: 0x79, &#39;F11&#39;: 0x7A, &#39;F12&#39;: 0x7B, &#39;F13&#39;: 0x7C, &#39;F14&#39;: 0x7D, &#39;F15&#39;: 0x7E, &#39;F16&#39;: 0x7F, &#39;F17&#39;: 0x80, &#39;F18&#39;: 0x81, &#39;F19&#39;: 0x82, &#39;F20&#39;: 0x83, &#39;F21&#39;: 0x84, &#39;F22&#39;: 0x85, &#39;F23&#39;: 0x86, &#39;F24&#39;: 0x87, &#39;num_lock&#39;: 0x90, &#39;scroll_lock&#39;: 0x91, &#39;left_shift&#39;: 0xA0, &#39;right_shift &#39;: 0xA1, &#39;left_control&#39;: 0xA2, &#39;right_control&#39;: 0xA3, &#39;left_menu&#39;: 0xA4, &#39;right_menu&#39;: 0xA5, &#39;browser_back&#39;: 0xA6, &#39;browser_forward&#39;: 0xA7, &#39;browser_refresh&#39;: 0xA8, &#39;browser_stop&#39;: 0xA9, &#39;browser_search&#39;: 0xAA, &#39;browser_favorites&#39;: 0xAB, &#39;browser_start_and_home&#39;: 0xAC, &#39;volume_mute&#39;: 0xAD, &#39;volume_Down&#39;: 0xAE, &#39;volume_up&#39;: 0xAF, &#39;next_track&#39;: 0xB0, &#39;previous_track&#39;: 0xB1, &#39;stop_media&#39;: 0xB2, &#39;play/pause_media&#39;: 0xB3, &#39;start_mail&#39;: 0xB4, &#39;select_media&#39;: 0xB5, &#39;start_application_1&#39;: 0xB6, &#39;start_application_2&#39;: 0xB7, &#39;attn_key&#39;: 0xF6, &#39;crsel_key&#39;: 0xF7, &#39;exsel_key&#39;: 0xF8, &#39;play_key&#39;: 0xFA, &#39;zoom_key&#39;: 0xFB, &#39;clear_key&#39;: 0xFE, &#39;+&#39;: 0xBB, &#39;,&#39;: 0xBC, &#39;-&#39;: 0xBD, &#39;.&#39;: 0xBE, &#39;/&#39;: 0xBF, &#39;`&#39;: 0xC0, &#39;;&#39;: 0xBA, &#39;[&#39;: 0xDB, &#39;\\&#39;: 0xDC, &#39;]&#39;: 0xDD, &quot;&#39;&quot;: 0xDE, &#39;`&#39;: 0xC0} &#39;&#39;&#39;]]></content>
      <tags>
        <tag>WHIMSY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recursion_Divide_and_conquer]]></title>
    <url>%2F2020%2F01%2F08%2FRecursion-Divide-and-conquer%2F</url>
    <content type="text"><![CDATA[递归与分治策略分割问题，缩小规模，原问题与子问题的解法的 二分搜索技术 大整数乘法 Strassen矩阵乘法 棋盘覆盖 合并线性和快速排序 线性时间选择 最接近点对问题 循环赛日程问题 入门：阶乘函数 斐波那契数列]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SortingAlgorithms]]></title>
    <url>%2F2019%2F12%2F29%2FSortingAlgorithms%2F</url>
    <content type="text"><![CDATA[比较类排序：冒泡排序、选择排序、快速排序、插入排序、希尔排序、归并排序、堆排序分配式排序：基数排序，计 是否基于比较、稳定性、是否需要额外空间数排序，桶排序 算法的基本思想（basic idea) 对排序算法执行的每一步追踪（trace）， 复杂度分析（time/space complexity） 伪代码（pseudocode） 一、冒泡排序从后向前扫描，遇到逆序的就做交换，例如42 20 17 13 28 14 23 15从后向前扫描：（假设升序排序）第一趟：23 与 15 逆序 swap-&gt;42 20 17 13 28 14 15 2328 与 14 逆序 swap-&gt;42 20 17 13 14 28 15 2317 与 13 逆序 swap-&gt;42 20 13 17 14 28 15 2320 与 13 逆序 swap-&gt;42 13 20 17 14 28 15 2342 与 13 逆序 swap-&gt;13 42 20 17 14 28 15 23可以发现这样最小值被放到了序列首部 int n; void bubSort(int *A) { for(int i=0;i&lt;n-1;i++) { for(int j=n-1;j&gt;i;j--) { if(A[j-1]&gt;A[j]) swap(A[j-1],A[j]); } } } 二、选择排序直接选择排序还是将待排序列分为无序区和有序区两块区域，一开始，待排序列为无序区，则从序列尾部向前扫描，找到本次扫描中的遇见的最小值，将其与首个元素交换位置，则无序序列被划分为有序区（最小值）+无序区 这时，就得到了一个新的size为n-1的无序序列（无序区），再对这n-1个元素做上述操作，找到这n-1个元素里的最小值，交换至新无序区(size=n-1的新无序序列)的首部，这样从整体来看，原size=n的待排序列被划分为，size=2：有序区size=n-2：无序区 int n; void SelSort(int *A) { for(int i=0;i&lt;=n-2;i++)//无序区间的最前端位置 { int minIndex=0; int minVal=2147483647; for(int j=n-1;j&gt;=i;j--)//扫描无序区间元素 { if(minVal&gt;A[j]) { minIndex=j; minVal=A[j]; } } swap(A[minIndex],A[i]); } } 优化选择排序也就是在找寻最小值的过程中顺便也把最大值找出来，这样每一趟排序就可以把当前待排序列中的最大值和最小值放到合适的位置（表尾和表头），代码就不写了，就在上面找最小值的部分下面再加一个做比较找最大值的代码块就行 三、快速排序在介绍快速排序之前，先简单介绍一下BST(二叉搜索树)的一些特性和实现思路作类比BST：在Shaffer的数据结构与算法中，二叉搜索树的左子树中的所有节点的关键码值（理解为Key值，就是一个用于比较的值，例如学生的成绩）小于根节点的关键码值，而右子树的所有节点的关键码值都大于或者等于其根节点的关键码值，这就有个好处了，当你寻找某个值的时候每次都可以把范围缩小一半去找，好比有序序列的区间二分查找 那设想有一个算法，能根据指定的某一位置（枢轴）把一无序序列分为左右两边，其中，左边的区域比枢轴值都要小右边区域的值比枢轴都要大（大于等于…），那么枢轴就处在了他该待在的位置，也就完成了一个元素的位置确定，然后再递归的对左区域和右区域使用这个算法，最后就可以得到有序序列了。 快速排序代码实现：按照自己的理解写的代码有些问题，目前还没想出错误，先放上来留待以后修改，qsort2是对的 代码分解讲解：template&lt;typename E&gt; inline int findpivot(E A[],int i,int j){return (i+j)/2;} //产生区间的中值作为枢轴 template&lt;typename E&gt; inline int partition_2(E A[],int l,int r,E pivot) { do{ while(A[++l]&lt;pivot); while((l&lt;r)&amp;&amp;pivot&lt;A[--r]); swap(A[l],A[r]); }while(l&lt;r); return l; } 对于给定的【l,r】下标区间的元素，根据上面的描述，枢轴左边的元素应当都比枢轴小，右边的都要比枢轴元素大，那么使用left指针从左边扫描，遇见比枢轴大的元素就停在这，使用right指针从右向左扫描，遇见比枢轴小的元素就停在这，这样left和right分别找到了两个不符合要求的元素（左边的元素都比枢轴元素小，右边的都要比枢轴元素大），那么交换left和right指针所指向的元素，就可以使之满足要求，像这样扫描下下去，直到left与right指针相遇，或者left指针跑到了right的右边的时候，就说明已经完成了任务：左边的区域比枢轴值都要小，右边区域的值比枢轴都要大 #include&lt;iostream&gt; using namespace std; int n; template&lt;typename E&gt; inline int findpivot(E A[],int i,int j){return (i+j)/2;} //产生区间的中值作为枢轴 template&lt;typename E&gt; int partition_(E A[],int l,int r,E PIVOT) { do{ while(1) { if((l&lt;r)&amp;&amp;A[l]&lt;A[PIVOT]) { l++; } else break; } while(1) { if((l&lt;r)&amp;&amp;A[PIVOT]&lt;A[r]) r--; else break; } //while((l&lt;r)&amp;&amp;A[l]&lt;pivot) l++; //while((l&lt;r)&amp;&amp;pivot&lt;A[r])r--; swap(A[l],A[r]); }while(l&lt;r); return l; } template&lt;typename E&gt; inline int partition_2(E A[],int l,int r,E pivot) { do{ while(A[++l]&lt;pivot); while((l&lt;r)&amp;&amp;pivot&lt;A[--r]); swap(A[l],A[r]); }while(l&lt;r); return l; } /* 10 72 6 57 88 60 42 83 73 48 85 */ template&lt;typename E&gt; void quickSort(E A[],int i,int j) { if(i&gt;=j)return ;//0或者1个元素不需要排序 int pivot=findpivot(A,i,j); swap(A[pivot],A[j]);//轴值置于序列末尾 int k=partition_(A,i,j-1,j); swap(A[k],A[j]);//轴值归位 for(int i=0;i&lt;n;i++) { cout&lt;&lt;A[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; quickSort(A,i,k-1); quickSort(A,k+1,j); } template&lt;typename E&gt; void quickSort2(E A[],int i,int j) { if(i&gt;=j)return ;//0或者1个元素不需要排序 int pivot=findpivot(A,i,j); swap(A[pivot],A[j]);//轴值置于序列末尾 int k=partition_2(A,i-1,j,A[j]); swap(A[k],A[j]);//轴值归位 quickSort2(A,i,k-1); quickSort2(A,k+1,j); } int main() { cin&gt;&gt;n; int *A=new int[n]; for(int i=0;i&lt;n;i++) { cin&gt;&gt;A[i]; } quickSort2&lt;int&gt;(A,0,n-1); for(int i=0;i&lt;n;i++) { cout&lt;&lt;A[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; return 0; } 四、插入排序想象一下，一堆打乱的牌放在桌子上（写有0~26的总共27张卡片），怎么才能变成有序呢，可以这样，左手拿牌，右手去一张张抽牌，右手拿第一张，将它直接放在左手里（一个元素自身有序）再去拿第二张，如果比第一张大，放在最右边，否则放在左边。拿第三张，这个时候左手里有两张牌了，右手拿着这张新牌，悬空着，从左手的最右边开始向左移动，找到合适位置插入到左手中（比如左手里的是1,5，拿到的是3，那么就插在1,5之间-&gt;1,3,5），这个合适的位置很显然就是，移动找位置过程中遇见的，第一个左相邻元素小于等于待插入元素的位置下面以n比较大的情况说明一下假如左手中的有序牌为：0 5 7 13 20 ，待插入牌为8号牌则：0 5 7 13 20 8-&gt;0 5 7 13 8 20-&gt;0 5 7 8 13 20 找到合适位置，结束 void insort(int *A) { for(int i=1;i&lt;n;i++)//右手取牌循环 {//i=1开始，因为左手里初始就拿了一张A[0]，所以右手从A[1]开始取牌向左手里插 for(int j=i;j&gt;=1;j--)//待插入牌寻找合适位置的循环 { if(A[j-1]&gt;A[j]) { swap(A[j-1],A[j]);//拿着右手的牌在悬在左手牌的上方 //在寻找合适插入位置的过程中，如果当前不合适，就向左交换 //可以自己再想一想右手牌寻找合适位置的情形 }else break; } } } 五、希尔排序改进版的插入排序，采用最小增量进行间断式的分组插入排序，每一组插入排序处理的数据规模减小代码解释以注释形式给出（略显简单^_^） void insort2(int *A,int incr) { for(int i=incr;i&lt;n;i+=incr)//如果对插入排序有一个比较深刻的思考，不难知道 {//修改后的插入排序，不过是把i++ i-- 这样的法则改为了i+=incr,i-=incr，从而实现了 //物理空间上的分隔，逻辑上的连续（逻辑上 i,i+incr，i+2*incr应当是连续的，同属于一个子序列） for(int j=i;j&gt;=incr;j-=incr) { if(A[j-incr]&gt;A[j])//类比A[j-1] A[j] 的比较 swap(A[j-incr],A[j]); else break; } } } void ShellSort(int *A) { for(int i=n/3;i&gt;2;i/=3)//用于增量生成的循环 i即为增量 { for(int j=0;j&lt;i;j++) insort2(&amp;A[j],i);//这个函数的传参比较细节，传的是A[j]元素的地址 } insort2(A,1);//做一次收尾的普通插入排序，但此时数据大致有序了 } for(int j=0;j&lt;i;j++) insort2(&amp;A[j],i);//这个函数的传参比较细节，传的是A[j]元素的地址 这一个循环单独讲一下，当选定一个增量来划分数据序列的时候，设增量为d，那么序列被划分为这么几组：A[0] A[d] A[2*d] … A[]A[1] A[1+d] A[1+2*d] … A[]……A[d-1] A[d-1+d] A[d-1+2*d] … A[]可以知道，每个子序列的起始端为0,1,2…d-1，且每个子序列的元素不相交（因为A[d]是A[0]开头的那一组的第二个元素，所以A[d-1]是最后一组子序列的开头） 所以，调用insort2函数传的是A[j]元素的地址，也就是每一组子序列的开头元素的地址 六、归并排序算法思想分治法的思想，逐层向下分解（这里做2路归并，向下做二分减小待排数据规模），当分解到规模为1或者2时，就可以很简单的给出当前规模下的有序序列了（2个可以做交换，1个本身就有序） 原序列-&gt;不断2分-&gt;数据量很小的序列直接排序-&gt;向上做合并-&gt;有序序列 代码实现分步骤解释递归出口void MergeSort(int b,int e/*begin and end index of array*/) { if(b==e) return; if(b+1==e){ if(c[b]&gt;c[e]) swap(c[b],c[e]); return ; } //这一块是对最下层的小序列做一个排序，使其有序，是递归的出口 递归分解 int mid = (b-e)/2+e;//防止大数之和超过范围 MergeSort(b,mid); MergeSort(mid+1,e);//二分数据元素序列，减小排序规模 合并两有序子序列分解完序列，并将小规模数据排完序后，向上做合并操作 合并思想对于待合并的两个有序子序列而言，可以开辟（最好全局声明吧）一个tempc[]数组存放中间结果，每一次比较量有序子序列的首部元素，选取两者中最小的（这里默认排序是按照升序方式进行）元素，放进tempc[]数组中，重复操作，得到即得到合并之后有序的数组，再将其拷贝回原数组c[] 合并步骤 int tempi=b,tempj=mid+1; for(int i=b;i&lt;=e;i++) { if(tempi&lt;=mid&amp;&amp;tempj&lt;=e) {//选取两有序子序列各自的最小值，再从二者里面选最小值 if(c[tempi]&lt;c[tempj]) { tempc[i]=c[tempi]; tempi++; }else{ tempc[i]=c[tempj]; tempj++; } }else{//其中一个子序列中的元素已被比较完，只需复制另一序列中的剩余元素即可 if(tempi&gt;mid) { while(tempj&lt;=e) { tempc[i]=c[tempj]; tempj++; i++; } break; }else{ while(tempi&lt;=mid) { tempc[i]=c[tempi]; tempi++; i++; } break; } } } for(int i=b;i&lt;=e;i++) { c[i]=tempc[i]; } 归并排序的循环实现堆排序计数排序假设输入的数据范围是25 ~ 552，则数据的最大值为MaxValue=552那就开一个计数数组Num,大小为553，这样Num数组能利用的下标范围为0-552,且Num数组元素初始化为0然后输入数据input,那么Num[input]++;用数组下标来进行分配，从而避免了排序，因为数组下标本身就是顺序排列的 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int maxV; int *A=new int[n]; for(int i=0;i&lt;n;i++) { cin&gt;&gt;A[i]; } maxV=A[0]; for(int i=1;i&lt;n;i++) { if(A[i]&gt;maxV) { maxV=A[i]; } } int *num=new int[maxV+1]; memset(num,0,(maxV+1)*sizeof(int)); for(int i=0;i&lt;n;i++) num[A[i]]++; for(int i=0;i&lt;maxV+1;i++) { if(num[i]&gt;0) { for(int j=0;j&lt;num[i];j++) cout&lt;&lt;i&lt;&lt;&#39; &#39;; } } return 0; } 桶排序使用某些规则划分出不同的桶，根据规则将输入数据分配到相应的桶中，然后每个桶中的数据规模减小，再使用其他排序方法在桶内部进行排序，在收集各桶中的元素即为排序后的结果， 基数排序]]></content>
      <tags>
        <tag>ChaoticDynamic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree]]></title>
    <url>%2F2019%2F12%2F28%2FTree%2F</url>
    <content type="text"><![CDATA[树父指针表示法每个节点只保存一个指针域，指向其父节点 等价类这里直接给出（离散数学中有介绍。。。），等价关系具有自反性、对称性、可传递性。举个简单的例子来理解一下，如果由A、B、C三座城市，给出等价对(A,B)(B,C)，则A、B双向通车，B、C双向通车，则可以认为A、C双向通车，称A、C等价，A、C应当归并为1个集合中（这里的关系是两城市是否连通，当然也可以是A是否是B的朋友这样的表达，这就是关系的两个例子）， 并查集 判断两个结点是否在同一集合中 归并两个集合 两个集合的合并常常被称为“并”UNION，合并的目的是为了之后方便的查询两结点是否在同一集合中。 主要实现Union Find Differ 三个函数来完成并查集 Differ:用于判断给出等价对中两结点是否已经属于同一集合，如果已经处于同一集合，则显然不需要使用合并操作（使用Find操作） Union合并两个集合（分为未使用加权合并和使用加权合并两种） Find:寻找到当前结点所在树的根节点（分为未使用路径压缩和使用路径压缩两个版本） 以下是本人根据对算法思想理解自己写的代码，有错误的话见谅（虽说目前测试没问题，毕竟自己的代码才有灵魂吗O(∩_∩)O~）。。。分解讲解一下思路： 加权合并当两个集合之间要做合并的时候，将元素少的集合向元素多的集合去合并，优点分析：这里的集合其实是一棵棵树，当合并两棵树的时候，如果将节点数少的树向节点数多的树合并，可以使得合并后节点数是至少是节点数少的树的两倍（这是显然的max &gt; min ; max + min&gt;=2*min）,但是高度最多只比合并之前的最大深度多1（试想一下，min和max的树的高度相同皆为h，那合并之后也不过h+1,至于其他的情况也可以自己画一画：高但少的树和矮但多的树合并，高但多的树和矮但少的树合并，合并之后也仍不过h_{MAX}+1） 路径压缩如果D的父节点是C,C的父节点是B，B的父节点是根节点A，那么想一想，既然大家的FIND操作都是为了找到根节点A，为什么不把D,C都像B直接指向A呢，这样以后执行Find操作的时候查找次数将大幅降低，因而在寻找D的根节点的时候，就把这一条路径上的所有节点指向根节点，从而缩短了Find路径 根节点标志ROOT = 2147483647 作为区分，节点是否为根节点的标志 主要物理存储结构uset数组：并查集节点数组，下标代表节点序号，数组元素存储的值代表其父节点序号，从而实现父指针表示法num数组：用于加权合并规则的实现时，方便得知两个待合并集合各集合所拥有的元素个数，以此为依据，进行两集合之间的加权合并 主要操作函数Find1（未使用路径压缩）根据父指针一路向上寻找 Find2（使用路径压缩）根据父指针一路向上寻找，递归寻找，这样当最后一层找到根节点返回的时候，可以将整条路径上的节点的父节点设置为根节点 differ使用Find函数，查找节点的根节点，从而判断是否属于同一集合 Union（使用加权合并规则）根据num数组中存储的集合元素数目进行比较，进行加权合并，至于合并操作非常简单，只需要Find得到两个待合并集合各自的根节点，将元素多的集合的根节点作为新根节点，设置为另一集合根节点的父节点即可。 应用举例曾经写过这样一个题目，森林中有一群猴子，一开始互相不认识，如果见面就会打架，打完架就成了好朋友（不打不相识…），且好朋友这种关系是一个等价关系，上面介绍过了，这里再阐述一下（好朋友关系是可以传递的：A是B的好朋友，B是C的好朋友，那么A是C的好朋友；对称的：A是B的好朋友，那么B也是A的好朋友）这样又给出一个好朋友圈的概念，会打架的两只猴子一定不属于同一个好朋友圈，并且如果他们将要打架，他们会请出自己好朋友圈里最强壮的朋友来帮他们打架，打架之后，两个好朋友圈将会合并。 显然，题目就是一个典型的并查集题目，题解就不放了。 #include&lt;iostream&gt; using namespace std; #define ROOT 2147483647 int *uset,*num; int Find1(int curr) { while(uset[curr]!=ROOT) curr=uset[curr]; return curr; } int Find2(int curr) { if(uset[curr]==ROOT)return curr; uset[curr]=Find2(uset[curr]); return uset[curr]; } bool differ(int a,int b,int(*Find)(int curr)) { if(Find(a)==Find(b)) return false; else return true; } void Union(int a,int b,int(*Find)(int curr)) { int RootOfa=Find(a); int RootOfb=Find(b); if(num[RootOfa]&lt;=num[RootOfb]) { uset[RootOfa]=RootOfb; num[RootOfb]+=num[RootOfa]; }else { uset[RootOfb]=RootOfa; num[RootOfa]+=num[RootOfb]; } } int main() { int n; cin&gt;&gt;n; uset=new int[n]; num=new int[n]; for(int i=0;i&lt;n;i++) { uset[i]=ROOT; num[i]=1; } cout&lt;&lt;&quot;输入等价对数量&quot;; int m; cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { int a,b; cin&gt;&gt;a&gt;&gt;b; if(differ(a,b,Find2)) { Union(a,b,Find2); } } for(int i=0;i&lt;n;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;uset[i]&lt;&lt;endl; return 0; } 以下的表示法在床上敲的，先不放图了，等我以后再回来放图，放图是需要鼠标的。。。。。。 树的表示法子节点表-表示法节点数组+子节点链表什么意思呢？就是说有一个数组，他的元素是树中所有结点，但是呢，同时每一个数组元素也是一个父节点，作为一个叫子节点链表的头节点 头节点组成元素： 自身的value值 指向父节点的索引值 指向子节点链表的指针（指向的其实是最左子节点） 子节点链表中的节点元素 自身的value值 指向右兄弟节点的指针 最左子节点/右兄弟-表示法每一个节点，有这么几个组成元素 自身的value值 指向父节点的索引 指向自己最左子节点的索引 指向自己的右兄弟的索引 动态节点-表示法子节点数目固定 子节点数+相应的子结点指针 子节点数目不固定 子节点指针链表 树的顺序表示法先根序列表示法把树的结点按照先根遍历顺序列出，把所有非空节点看成分支节点，只有空指针 NULL被当作叶子节点AB/D//CEG///FH//I//然后来重构一下这棵树A root节点B A的左子节点 / 说明B无左子节点，B的左子树遍历完毕 紧随其后的是B的右子树，D说明D是B的右子节点，]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1908]]></title>
    <url>%2F2019%2F12%2F18%2FLuoguP1908%2F</url>
    <content type="text"><![CDATA[题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i &lt; j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 总之就是计算逆序对数目 暴力法 归并排序 树状数组 暴力法不讲了，就是枚举，平方复杂度 归并排序#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;cstdlib&gt; using namespace std; int c[500000+10]; int tempc[500000+10]; int ans=0; void MergeSort(int b,int e)//begin and end index of array) { if(b==e) return ; if(b+1==e){ if(c[b]&gt;c[e]) { swap(c[b],c[e]); ans+=1; } return; } int mid = (b-e)/2+e; MergeSort(b,mid); MergeSort(mid+1,e); int tempi=b,tempj=mid+1; for(int i=b;i&lt;=e;i++) { if(tempi&lt;=mid&amp;&amp;tempj&lt;=e) { if(c[tempi]&lt;c[tempj]) { tempc[i]=c[tempi]; tempi++; }else{ while(tempi&lt;=mid) { if(c[tempi]==c[tempj]) { tempc[i]=c[tempi]; i++; tempi++; } else{ ans+=mid-tempi+1; break; } } tempc[i]=c[tempj]; tempj++; } }else{ if(tempi&gt;mid) { while(tempj&lt;=e) { tempc[i]=c[tempj]; tempj++; i++; } break; }else{ while(tempi&lt;=mid) { tempc[i]=c[tempi]; tempi++; i++; } break; } } } for(int i=b;i&lt;=e;i++) { c[i]=tempc[i]; } } int main() { ans=0; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;c[i]; //c[i]=n-i; } MergeSort(0,n-1); cout&lt;&lt;ans; return 0; } 树状数组]]></content>
      <tags>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DynamicProgramming]]></title>
    <url>%2F2019%2F12%2F17%2FDynamicProgramming%2F</url>
    <content type="text"><![CDATA[【动态规划】 01背包问题：有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和 给出一个例子作为讲解：物品数目number＝4，背包容量capacity＝8i（物品编号） 1 2 3 4w（体积） 2 3 4 5v（价值） 3 4 5 6这里就有必要引入：决策、最优解、状态、状态转移方程了，但并不线给出抽象的定义，而是用通俗一点的方式理解 假如我们现在的背包是空的，剩余容量c为8，开始从一号物品往后装（顺序去拿），那么对于某一个物品而言，就有拿与不拿两种处理方式（这里就是决策，做出的判断与行动），然后相应的有两种分支， 把第一件物品装进包，那么包的剩余容量会减小，但是包里的总价值会增加 不装第一件物品，那么包的容量和其内部物品的价值保持不变，都是0这里包就有了两种属性，容量和价值（即包的状态）每一次的决策，会带来状态之间的变化，可以找出一定的关系式（状态转移方程，方便计算机进行迭代） 1号决策-&gt;2号决策-&gt;3号决策-&gt;4号决策 1号最优解=全局最优解=最优（1号决策产生的所有分支） 换句话说，1号决策产生了两条路径，答案总会出现在两条路径中的其中一条举个例子理解一下：capacity=8,value=0对于第一个物品，两种决策（背包容量比较大）这里不妨引入一个初态state0:capacity=8,value=0 拿： capacity=6,value=3 state0-&gt;state1 不拿：capacity=8,value=0 state0-&gt;state2那么，你再分别基于这两个状态的背包，进行二号决策，又会产生四个状态（如果背包空间还是比较大的话）但是先到这里，最优解的产生一定是一系列决策的共同作用，也就是有一个最优决策序列。那么再来重复下上面那句话：1号最优解=全局最优解=最优（1号决策产生的所有分支，这里的例子是2个） 那么当我们做2号决策的时候，可以看见的是背包有两个状态，又或者说，要基于这两个状态的背包分别做决策state1:那么其实 state1 就是一个新的state0了state2:同理state2 也是一个新的state0 这样,2号决策就拥有了与1号决策相似的结构了，它的最优解称为子最优解那么来一个不正式的理解：全局最优解=最优(子最优解)子最优解=最优（子子最优解）…其实呢，动态规划，个人是觉得听不太好阐述清楚，有时间对比一下其他的一些思想和方法一起理解 洛谷P1060 开心的金明状态转移方程 opt\[N_{i}][i]=\begin{Bmatrix} max(opt\[N_{i}-n_{i}][i+1]+v_{i}\cdot p_{i},opt\[N_{i}][i+1]),N_{i}\geqslant n_{i}\\\\ opt\[N_{i}][i+1],N_{i}< n_{i} \end{Bmatrix} 递归实现#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int opt[3000][27]; int v[27+2],p[27+2]; int N,m; int dp(int Ni,int i/*id*/) { if(i==m) return Ni&gt;=v[m]?v[m]*p[m]:0; return Ni&gt;=v[i]?/*背包容量比较充裕，可做两种决策*/ max( dp(Ni-v[i],i+1)+v[i]*p[i] , dp(Ni,i+1)) :/*背包容量不充裕，不能放当前物品*/ dp(Ni,i+1); } int main() { cin&gt;&gt;N&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;v[i+1]&gt;&gt;p[i+1]; //id=i+1 } cout&lt;&lt;dp(N,1); return 0; } 记忆化搜索#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int opt[3000][27]; int DP[3000][27]; int v[27+2],p[27+2]; int N,m; int dp(int Ni,int i/*id*/) { if(i==m) return Ni&gt;=v[m]?v[m]*p[m]:0; if(DP[Ni-v[i]][i+1]==-1) DP[Ni-v[i]][i+1]=dp(Ni-v[i],i+1); if(DP[Ni][i+1]==-1) DP[Ni][i+1]=dp(Ni,i+1); return Ni&gt;=v[i]?/*背包容量比较充裕，可做两种决策*/ max( DP[Ni-v[i]][i+1]+v[i]*p[i] , DP[Ni][i+1]) :/*背包容量不充裕，不能放当前物品*/ DP[Ni][i+1]; } int main() { cin&gt;&gt;N&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;v[i+1]&gt;&gt;p[i+1]; //id=i+1 } memset(DP,-1,3000*27*sizeof(int)) ; cout&lt;&lt;dp(N,1); return 0; } 循环实现#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int opt[3000][27+2]; int v[27+2],p[27+2]; int main() { int N,m; cin&gt;&gt;N&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;v[i+1]&gt;&gt;p[i+1]; //id=i+1 } for(int i=0;i&lt;=N;i++) { opt[i][m]= i&gt;=v[m]?v[m]*p[m]:0;//最后一步的决策是可以直接给出的 //初始化 } for(int i=m-1;i&gt;=1;i--) { for(int j=0;j&lt;=N;j++) { opt[j][i]= j&gt;=v[i]? max(opt[j-v[i]][i+1]+v[i]*p[i],opt[j][i+1]): opt[j][i+1];//把上面的状态转移方程coding一下 } } for(int i=0;i&lt;=m;i++) { for(int j=0;j&lt;=N;j++) { printf(&quot;%3d &quot;,opt[j][i]); } cout&lt;&lt;endl; } cout&lt;&lt;endl&lt;&lt;opt[N][1]; return 0; } 空间压缩当然这里可以通过循环控制，将二维数组压缩为一维数组 for(int i=0;i&lt;m;i++) { cin&gt;&gt;v[i+1]&gt;&gt;p[i+1]; //id=i+1 } for(int i=0;i&lt;=N;i++) { opt[i]= i&gt;=v[m]?v[m]*p[m]:0;//最后一步的决策是可以直接给出的 //初始化 } for(int i=m-1;i&gt;=1;i--) { for(int j=N;j&gt;=0;j--) { opt[j]= j&gt;=v[i]? max(opt[j-v[i]]+v[i]*p[i],opt[j]): opt[j];//把上面的状态转移方程coding一下 } } cout&lt;&lt;endl&lt;&lt;opt[N];]]></content>
      <tags>
        <tag>ChaoticDynamic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShortestPath]]></title>
    <url>%2F2019%2F12%2F10%2FShortestPath%2F</url>
    <content type="text"><![CDATA[临时路线. 最短路径：什么是最短路径？最短路径是指从某一顶点出发到达另一顶点，可能存在许多路径，则某路径上的各边权值之和最小，则为最短路径 问题解法 边上权值非负情形的单源最短路径问题：Dijksta算法 边上权值为任意值的单源最短路径问题（不可有带负权边的回路）：Bellman-Ford算法 所有顶点之间的最短路径（全源最短路径）：Floyd算法和Johonson算法 值得注意的的是：最短路径问题具备最优子结构性质，也就是两顶点之间的最短路径包括路径上其他顶点的最短路径。 反证法证明：如果不包含，也就是说有办法使得换了路径上的某些顶点，可以使得仍到达目的地，但是总路径可以变短，这显然是和最短路径相违背的。符号化一些的描述呢，有一条最短路径&lt; i,j &gt;,这条路径上会经过许多点，设为i,v_{1},v_{2}...v_{t},j，如果假设成立，那么设当前从v_{1}到v_{2}这条小路径不是他们之间的最短路径，那么总存在另一条更短的路径可以使得从v_{1}到v_{2}更短，这样就会造成i可以到j，且路径缩短，与大前提&lt; i,j &gt;是最短路径相违背，得证 带权图的单源最短路径Floyd算法\Floyd-Warshall算法Floyd算法.有一说一，讲的可以ヾ(≧▽≦*)o简述一下：初始化图-&gt;加载各点的路径长（矩阵存储）-&gt;顺序引入新的中转点-&gt;遍历更新路径长的矩阵-&gt;继续引入继续更新 for(k=1;k&lt;=n;k++) {//迭代更新新的中转点 for(i=1;i&lt;=n;i++) {//两层循环 遍历更新 路径长度矩阵 的值 for(j=1;j&lt;=n;j++) { if(e[i][j]&gt;e[i][k]+e[k][j]) { e[i][j]=e[i][k]+e[k][j]; } } } } 边权非负情形Dijkstra算法源点该算法使用的是贪心策略：每次都找出剩余顶点中与源点距离最近的一个顶点。参考：Dijkstra算法 算法思想带权图G=令S为已确定了最短路径顶点的集合，则可用V-S(V集合减去S集合)表示剩余未确定最短路径顶点的集合。假设V0是源点，则初始 S={V0}。用数组Distance表示源点V0到其余顶点的路径长度，用数组pre[i]表示最短路径序列上顶点i的前一个顶点。初始时，pre[i]都是源点的下标。接下来需重复两个步骤： 从当前Distance[i]找出最小的一个，记录其下标v=i，源点V0到顶点Vv的最短路径即已确定，把Vv加入S。更新源点到剩余顶点的最短路径长度。更新方法是：以上一步的顶点Vv为中间点，若Distance[v]+weight(v,i)小于Distance[i]，则修改值：pre[i]=v;Distance[i]=Distance[v]+weight(v,i);重复以上两个步骤，直至所有顶点的最短路径都已找到.。需要指出，Dijkstra算法求解的不仅是有向图，无向图也是可以的。下面给出一个完整的有向带权图的实例： 边上权值为任意值的情形（不可有带负权边的回路）SPFA算法\Bellman-Ford算法 核心思想：当图中没有由带负权值的边组成的回路时，有n个顶点的图中任意两点之间如果存在最短路径，此路径最多有n-1条边。这是显然的，从i到j的路径,最多就是把其他所有节点经历过一遍，何况是最短路径 算法思想：记dist[u]为源点v到其他顶点u的最短路径长度 先看一下红线标注的文字，最多这两个字很精髓，这样的话可以发现dist^{i}[u]包含了dist^{i}[u]（最多包含三条边当然范围比最多包含两条边大了既然范围大，那么其利用的条件与资源就可以越充分）为什么最终目的是要求出dist^{n-1}[u]呢，由上面的理解可以知道，dist^{i}[u]的i越大，其范围越大，所使用的的资源越充分，更接近于答案递归关系式： dist^{k}[u]=min\begin{Bmatrix} dist^{k-1}[u],& min\begin{Bmatrix}dist^{k-1}[j]+Edge\[j][u] \end{Bmatrix} \end{Bmatrix}递归出口：dist^{1}[u]=Edge\[v][u] 当然，可以使用循环从最底层逐层往上计算 Johnson算法A*算法]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNUACM10011]]></title>
    <url>%2F2019%2F12%2F04%2FHNUACM10011%2F</url>
    <content type="text"><![CDATA[Problem descriptionThe inversion number of an integer sequence a1, a2, . . . , an is the number of pairs (ai, aj) that satisfy i &lt; j and ai &gt; aj . Given n and the inversion number m, your task is to find the smallest permutation of the set { 1, 2, . . . , n }, whose inversion number is exactly m.A permutation a1, a2, . . . , an is smaller than b1, b2, . . . , bn if and only if there exists an integer k such that aj = bj for 1 &lt;= j &lt; k but ak &lt; bk.InputThe input consists of several test cases. Each line of the input contains two integers n and m. Both of the integers at the last line of the input is −1, which should not be processed. You may assume that 1 &lt;= n &lt;= 50000 and 0 &lt;= m &lt;= n(n − 1)/2. OutputFor each test case, print a line containing the smallest permutation as described above, separates the numbers by single spaces. Sample Input5 97 3-1 -1Sample Output4 5 3 2 11 2 3 4 7 6 5Problem SourceShanghai-P 2004 题目中文解释就是说给你两个数n和m，你需要给出1~n得到某种排列方式，使得该序列的逆序数的对数为m，如果有多个符合条件的序列的话，应当给出最小的序列（序列大小比较规则类似字典序） 解法来源介绍额…我暂时没看过题解，走在上课路上无聊，大概比划了一下，给出了一种解法，等一下给出适当的证明 解法简介（有些名词自己起的，比较中二，但我喜欢）先来看看两个最特殊的序列例如n=7的时候序列1：1234567序列2：7654321 为什么说特殊呢，是因为这分别是序列集合的上边界和下边界，因为他们的逆序数的对数为min=0和max=\frac{n\cdot (n-1)}{2} 由于是要求符合条件的最小序列，那么根据贪心的思想答案序列的最终样子大概会长这样子：【一段顺序递增序列】【一段比较乱序的序列，大体上是倒序的】，额..为什么这么描述呢，因为我就是这么想的 随便给一个m=3 我先在这里给出两个我思考时候定义的名词 下界序列 增量因子再给出一些会用到的公式：定义NUM[n]为 长度为n的序列的最大逆序数的对数根据max公式知道： NUM[n]=\frac{n\cdot (n-1)}{2} NUM[n-1]=\frac{(n-1)\cdot (n-2)}{2} 有序区间 和 无序区间 分别对应 【一段顺序递增序列】【一段比较乱序的序列，大体上是倒序的】 的左半部分和右半部分有一说一，确实很中二，但是很形象， 由于m=3,那么看一下怎样的序列可以满足序列一：1 2 3 4 5 6 | 7:0序列二：1 2 3 4 5 | 7 6:1序列三：1 2 3 4 | 7 6 5:3序列四：1 2 3 | 4 5 6 7:6 是的，序列三就满足了，但是为什么要算到序列四呢？嗯，这里再给出m=4时的思考过程 注意到之所以序列三能带来3的逆序数对数，是因为他的无序区间长度为3，或者说7 6 5 这一无序区间内的元素个数为3因而就有NUM[3]=3，再比如序列四的逆序数对数就应该是NUM[4]=4*3/2=6 这时候发现m=4并没有对应的序列，但是同时可以思考到，它夹在3和6之间，是不是可以调节一下，使得它们变成需要的序列呢？ 这里叫3为 m=4的下界，对应的下界序列为7 6 5，下界序列的元素个数为3 ， 由于7 6 5 这个序列的逆序数对数的极限大小就是3了，所以必须要引入改变，才可能变多 在尽可能保持有序序列有序性的情况下，以下界序列所在的序列（这里是序列三）为基础，引入增量因子（即再动用一个数，向序列四靠近，这里是序列三中最靠近分界线的4）： 思考的精髓之处动用4 对序列三做调节，向序列四靠近，即由下界向上界的移动 1 2 3 | 4 | 7 6 5 做准备的序列三 4作为增量因子去置换7 6 5 将会产生如下的变化：4 不换 那就是序列三 NUM=3 4 置换5 那么就有 5 | 7 6 4，不论 7 6 4 如何变化 5 作为增量因子 能带来的逆序数对数的增量为1，因为他是这四个数里倒数第二大的，肯定比7 6 小，但是比4大，这时序列的逆序数对数为NUM= 增量因子5带来的增量delta=1 + numOf(7,6,4)所产生的最大对数3，这是为了维持下界序列提供的逆序数对数，故将7 6 4 三个元素排列为 降序 也就是7 6 4 4 置换6 那么就有 6 | 7 4 5，同样的分析，增量因子6能带来的增量为常值2，调节后NUM=2+3=5 这样的两种调节分别产生了 NUM=4 NUM=5 均介于 3 和 6之间 还可以 没做任何优化 没任何算法 一次通过 排名55 nice 下面贴上代码和纸上的一些演示：还有一段证明没给出，有时间再写吧（要写作业了） #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; using namespace std; vector&lt;long long int&gt;result; int main() { bool IsFirstIn=true; while(1) { long long int n,m; cin&gt;&gt;n&gt;&gt;m; if(n==-1&amp;&amp;m==-1) return 0; //n*(n-1)=m*2; if(IsFirstIn) IsFirstIn=false; else{ cout&lt;&lt;endl; } long long int downBorder=(1+sqrt(1+8*m))/2; //123 4 765 for(int i=1;i&lt;=n-(downBorder+1);i++) { result.push_back(i); } long long int Goal_Delta=m- downBorder*(downBorder-1)/2; //3~6---7 delta of 6 is 2 6-&gt;2 5-&gt;1 4-&gt;0 result.push_back(n-downBorder+Goal_Delta); //cout&lt;&lt;n-downBorder+Goal_Delta; for(int i=n;i&gt;=n-downBorder;i--) { if(i!=n-downBorder+Goal_Delta) result.push_back(i); } for(int i=0;i&lt;result.size();i++) { if(i==0) { cout&lt;&lt;result[i]; }else cout&lt;&lt;&#39; &#39;&lt;&lt;result[i]; } result.erase(result.begin(),result.end()); } return 0; } 我还得写数电作业和完成CPU的综合设计，忙中刷题，抽空会维护以前的题解的。]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNUACM10007]]></title>
    <url>%2F2019%2F12%2F03%2FHNUACM10007%2F</url>
    <content type="text"><![CDATA[include#include&lt;ctime&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; typedef long long ll; map&lt;ll, int&gt;m; const int mod = 10000019; const int times = 50;//测试50次 ll mul(ll a, ll b, ll m) //求a*b%m { ll ans = 0; a %= m; while(b) { if(b &amp; 1)ans = (ans + a) % m; b /= 2; a = (a + a) % m; } return ans; } ll pow(ll a, ll b, ll m) //a^b % m { ll ans = 1; a %= m; while(b) { if(b &amp; 1)ans = mul(a, ans, m); b /= 2; a = mul(a, a, m); } ans %= m; return ans; } bool Miller_Rabin(ll n, int repeat)//n是测试的大数，repeat是测试重复次数 { if(n == 2 || n == 3)return true;//特判 if(n % 2 == 0 || n == 1)return false;//偶数和1 //将n-1分解成2^s*d ll d = n - 1; int s = 0; while(!(d &amp; 1)) ++s, d &gt;&gt;= 1; //srand((unsigned)time(NULL));在最开始调用即可 for(int i = 0; i &lt; repeat; i++)//重复repeat次 { ll a = rand() % (n - 3) + 2;//取一个随机数,[2,n-1) ll x = pow(a, d, n); ll y = 0; for(int j = 0; j &lt; s; j++) { y = mul(x, x, n); if(y == 1 &amp;&amp; x != 1 &amp;&amp; x != (n - 1))return false; x = y; } if(y != 1)return false;//费马小定理 } return true; } ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); } ll pollard_rho(ll n, ll c)//找到n的一个因子 { ll x = rand() % (n - 2) + 1; ll y = x, i = 1, k = 2; while(1) { i++; x = (mul(x, x, n) + c) + n;//不断调整x2 ll d = gcd(y - x, n); if(1 &lt; d &amp;&amp; d &lt; n) return d;//找到因子 if(y == x) return n;//找到循环，返回n，重新来 if(i == k)//一个优化 { y = x; k &lt;&lt;= 1; } } } void Find(ll n, ll c) { if(n == 1)return;//递归出口 if(Miller_Rabin(n, times))//如果是素数，就加入 { m[n]++; return ; } ll p = n; while(p &gt;= n) p = pollard_rho(p, c--);//不断找因子，知道找到为止，返回n说明没找到 Find(p, c); Find(n / p, c); } void PrintMin(ll n) { srand((unsigned)time(NULL)); m.clear(); Find(n, rand() % (n - 1) + 1);//这是自己设置的一个数 //cout&lt;&lt;n&lt;&lt;&quot; = &quot;; ll min= m.begin()-&gt;first; for(map&lt;ll ,int&gt;::iterator it = m.begin(); it != m.end();it++) { //cout&lt;&lt;it-&gt;first&lt;&lt;&quot; ^ &quot;&lt;&lt;it-&gt;second; if((*it).first&lt;min) { min=(*it).first; } } cout&lt;&lt;min&lt;&lt;endl; } int main() { int t; cin&gt;&gt;t; for(int i=0;i&lt;t;i++) { ll n; cin&gt;&gt;n; if(Miller_Rabin(n, times)) { cout&lt;&lt;&quot;Prime&quot;&lt;&lt;endl; } else{ PrintMin(n); } } return 0; }]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pollard_rho]]></title>
    <url>%2F2019%2F11%2F24%2FPollard-rho%2F</url>
    <content type="text"><![CDATA[大数因式分解 Pollard_rho 算法大致流程：先判断当前数是否是素数（Miller_rabin），如果是则直接返回。如果不是素数的话，试图找到当前数的一个因子（可以不是质因子）。然后递归对该因子和约去这个因子得到的另一个因子进行分解。//gcd 欧几里得算法见BasicAlgorithm post 参考资料 Concepts used in Pollard’s Rho Algorithm: 一、Two numbers x and y are said to be congruent modulo n (x = y modulo n)： 1. if their absolute difference is an integer multiple of n, OR 2. each of them leaves the same remainder when divided by n. //x 和 y 同余 二、The Greatest Common Divisor is the largest number which divides evenly into each of the original numbers.//最大公约数 三、Birthday Paradox: The probability of two persons having same birthday is unexpectedly high even for small set of people.//生日悖论 四、Floyd’s cycle-finding algorithm: If tortoise and hare start at same point and move in a cycle such that speed of hare is twice the speed of tortoise, then they must meet at some point.//如果乌龟和兔子在同一点开始，并且以兔子的速度是乌龟速度的两倍的循环运动，那么它们必须在某个点相遇。 Algorithm: Start with random x and c. Take y equal to x and f(x) = $$x^{2}$$ + c. While a divisor isn’t obtained Update x to f(x) (modulo n) [Tortoise Move] Update y to f(f(y)) (modulo n) [Hare Move] Calculate GCD of |x-y| and n If GCD is not unity If GCD is n, repeat from step 2 with another set of x, y and c Else GCD is our answer //优化版 ll pollard_rho(ll n, ll c)//找到n的一个因子 { ll x = rand() % (n - 2) + 1; ll y = x, i = 1, k = 2; while(1) { i++; x = (mul(x, x, n) + c) + n;//不断调整x2 ll d = gcd(y - x, n); if(1 &lt; d &amp;&amp; d &lt; n) return d;//找到因子 if(y == x) return n;//找到循环，返回n，重新来 if(i == k)//一个优化 { y = x; k &lt;&lt;= 1; } } //原始版 ll pollard_rho2(ll n, int c)//找到n的一个因子 { ll x = rand() % (n - 2) + 1; ll y = x, k = 2; while(1) { x = (mul(x,x, n) + c) + n;//不断调整x2 y= (mul(y,y, n) + c) + n; y= (mul(y,y, n) + c) + n; ll d =gcd(y-x&gt;0?y-x:x-y , n); if(1 &lt; d &amp;&amp; d &lt; n) return d;//找到因子 if(d == n) return n;//找到循环，返回n，重 新来 if(d==1) return n; } } void Find(ll n, ll c) { if(n == 1)return;//递归出口 if(Miller_Rabin(n, times))//如果是素数，就加入 { m[n]++; return ; } ll p = n; while(p &gt;= n) p = pollard_rho(p, c--);//不断找因子，知道找到为止，返回n说明没找到 Find(p, c); Find(n / p, c); }]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PrimeJudge]]></title>
    <url>%2F2019%2F11%2F22%2FPrimeJudge%2F</url>
    <content type="text"><![CDATA[Miller_Rabin（米勒-拉宾）素数判别法：时间复杂度O(logn) 质数:是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 互质(互素：互质是公约数只有1的两个整数，叫做互质整数。公约数只有1的两个自然数，叫做互质自然数，后者是前者的特殊情形。 同余： 同余式是数论的基本概念之一，设m是给定的一个正整数，a、b是整数，若满足m|(a-b)，则称a与b对模m同余，记为a≡b(mod m)，或记为a≡b(m)。这个式子称为模m的同余式，若m∤ (a-b)，则称a、b对模m不同余，同余概念又常表达为： 1.a=b+km(k∈Z)； 2.a和b被m除时有相同的余数。 同余式的记号由高斯(Gauss,C.F.)于1800年首创,发表在他的数论专著《算术研究》之中。 快速幂：均见BasicAlgorithm post 快速积：均见BasicAlgorithm post 位运算：均见BasicAlgorithm post 费马小定理：设p是素数，a与p互素，则 a^{(p-1)}\equiv 1(mod p) 二次探测：如果p是素数，x是小于p的正整数，且x^{2}\equiv1(modp)那么要么x=1，要么x=p-1值得注意的是有一条推导结论(原论文长达500多页，我找不着，就不看了，只找到了引用该结论的其他文章)在如下算法流程中：有的d,r,n,a几个重要参数其中给出结论： 其中这份代码算是所看博客遇见最为清晰的一份之一了 清晰版#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int prime[10]={2,3,5,7,11,13,17,19,23,29}; int Quick_Multiply(int a,int b,int c) //快速积（和快速幂差不多） { long long ans=0,res=a; while(b) { if(b&amp;1) ans=(ans+res)%c; res=(res+res)%c; b&gt;&gt;=1; } return (int)ans; } int Quick_Power(int a,int b,int c) //快速幂，这里就不赘述了 { int ans=1,res=a; while(b) { if(b&amp;1) ans=Quick_Multiply(ans,res,c); res=Quick_Multiply(res,res,c); b&gt;&gt;=1; } return ans; } bool Miller_Rabin(int x) //判断素数 { int i,j,k; int s=0,t=x-1; if(x==2) return true; //2是素数 if(x&lt;2||!(x&amp;1)) return false; //如果x是偶数或者是0,1，那它不是素数 while(!(t&amp;1)) //将x分解成(2^s)*t的样子 { s++; t&gt;&gt;=1; } for(i=0;i&lt;10&amp;&amp;prime[i]&lt;x;++i) //随便选一个素数进行测试 { int a=prime[i]; int b=Quick_Power(a,t,x); //先算出a^t for(j=1;j&lt;=s;++j) //然后进行s次平方 { k=Quick_Multiply(b,b,x); //求b的平方 if(k==1&amp;&amp;b!=1&amp;&amp;b!=x-1) //用二次探测判断 return false; b=k; } if(b!=1) return false; //用费马小定律判断 } return true; //如果进行多次测试都是对的，那么x就很有可能是素数 } int main() { int x; scanf(&quot;%d&quot;,&amp;x); if(Miller_Rabin(x)) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); return 0; } 简洁版bool isPrime(ll a,ll n) {//a is test ll d =n-1; if(n&lt;1) return false; if(n==2) return true; if(!(n&amp;1)) return false; while(!(d&amp;1)) d&gt;&gt;=1; ll t=Quick_Power(a,d,n); while(d!=n-1&amp;&amp;t!=1&amp;&amp;t!=n-1) { t=Quick_Power(t,2,n); d&lt;&lt;=1; } return (t==n-1)||(d&amp;1); }]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Knapsackproblem]]></title>
    <url>%2F2019%2F11%2F21%2FKnapsackproblem%2F</url>
    <content type="text"><![CDATA[0-1 背包问题给定n个重量为w_{1},w_{2},..,w_{n}的物品，价值为v_{1},v_{2},…,v_{n}的物品和容量为C的背包，求这个物品中一个最有价值的子集，使得在满足背包的容量的前提下，包内的总价值最大 方案一:递归求解递归遍历解空间树，枚举，2_{n}（会因为剪枝而大大减少）种情况 answer[1~n]=max(选择物品1:value[1]+answer[2~n] 但是背包容量减少，不选择物品1+answer[2~n]背包容量不变) #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; int n; int w[100],v[100]; int Enum(int index,int c) { if(c&lt;0) return 0; if(index&gt;n-1) return 0; if(c&gt;=w[index]) { return max( v[index]+Enum(index+1,c-w[index]),Enum(index+1,c) ); } else{ return Enum(index+1,c); } } int main() { cin&gt;&gt;n; int c; cin&gt;&gt;c; for(int i=0;i&lt;n;i++) { cin&gt;&gt;w[i]&gt;&gt;v[i]; } cout&lt;&lt;Enum(0,c); return 0; }]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LongestIncreasingSubsequence]]></title>
    <url>%2F2019%2F11%2F21%2FLongestIncreasingSubsequence%2F</url>
    <content type="text"><![CDATA[最长上升子序列两种方法介绍法一：dp状态转移法二：贪心+二分做法：思路：1. 求最长递增子序列的长度时，我们使用二分查找的方法求，具体的操作是维护一个辅助数组，这个辅助数组dp[k]中保存着当前已经获得最长递增子序列，k表示当前的辅助数组中递增序列的个数，当处理原数组中下一个元素data[i]时，1）若data[i] &gt; dp[k - 1]时， 直接dp[k++] = data[i];2) 否则，使用二分查找在dp中找到第一个不大于data[i]的元素的位置j, 使得dp[j] = data[i]; 方法1复杂度O(n_{2})理解State:Length[index][TailHeight]-&gt; 1. Length[index+1][TailHeight] 当前元素不能接在LIS后面，下一状态继承当前状态 2. Length[index+1][Height[index]]+1 or Length[index+1][TailHeight]当前元素能接在LIS后面，下一状态基于当前状态做出两种决策 分析一下最终结果 假如输入序列中有n个元素，那么记最后结果为dp[n]显然 dp[n]= max(dp[i,i\epsilon[1,n]]+ element[n]&gt;element[i]?1:0; ) dp[i]为 以element[i]结尾的序列问题的最优解 状态转移方程：dp[i]=max(dp[j,j\epsilon[1,i）])+ element[i]]&gt;element[j]?1:0; )answer:dpcin:element 如果已经求出前n-1个元素的最优解，那么可以求出前n个元素的最优解如果已经求出前n-2个元素的最优解，那么可以求出前n-1个元素的最优解….初始化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #define M 2000000 + 5 int a[M],f[M],b[M]; int ans,n,k; int main(){ scanf(&quot;%d&quot;,&amp;n); for ( int i = 1;i &lt;= n; ++ i){ scanf(&quot;%d&quot;,&amp;a[i]); f[i] = 1; } for ( int i = 2;i &lt;= n; ++ i) for ( int j = 1;j &lt; i; ++ j) if (a[j] &lt; a[i] &amp;&amp; f[j] + 1 &gt; f[i]) f[i] = f[j] + 1; for ( int i = 1;i &lt;= n; ++ i) if (f[i] &gt; ans) ans = f[i]; printf(&quot;%d\n&quot;,ans); } 方法2复杂度O(n\log n)1.lower_bound(起始地址，结束地址，要查找的数值) 返回的是大于或等于val的第一个元素位置 2.upper_bound(起始地址，结束地址，要查找的数值) 返回的是返回大于val的第一个元素位置 3.binary_search(起始地址，结束地址，要查找的数值) 返回的是是否存在这么一个数，是一个bool值。 1.2.两个函数的用法类似，在一个左闭右开的有序区间里进行二分查找，需要查找的值由第三个参数给出。 对于upper_bound来说，返回的是被查序列中第一个大于查找值的指针，也就是返回指向被查值&gt;查找值的最小指针，lower_bound则是返回的是被查序列中第一个大于等于查找值的指针，也就是返回指向被查值&gt;=查找值的最小指针。 不过除此之外，这两个函数还分别有一个重载函数，可以接受第四个参数。如果第四个参数传入greater&lt;Type&gt;()，其中Type改成对应类型，那么upper_bound则返回指向被查值&lt;查找值的最小指针，lower_bound则返回指向被查值&lt;=查找值的最小指针。 此外，如果你用上述两个函数三个参数的那种形式，记得那个左闭右开的区间要为非递减的顺序，如果你给第四个参数传入greater&lt;Type&gt;()，则区间为非递增的顺序。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int greedy[1000+5]; int a[1000+5]; int main() { memset(greedy,0,1005*sizeof(int)); memset(a,0,1005*sizeof(int)); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } greedy[0]=a[0]; int endIndex=0; for(int i=1;i&lt;n;i++) { if(a[i]&gt;greedy[endIndex]) { endIndex++; greedy[endIndex]=a[i]; } else{ if(a[i]&lt;greedy[endIndex]) {//??? a[upper_bound(greedy,greedy+endIndex+1,a[i])-&amp;(a[0])]=a[i]; } } } cout&lt;&lt;endIndex+1; /*cout&lt;&lt;binary_search(a,a+n,3)&lt;&lt;endl; cout&lt;&lt;upper_bound(a,a+n,3)-&amp;(a[0]); cout&lt;&lt;endl&lt;&lt;lower_bound(a,a+n,3)-a;*/ return 0; }]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search]]></title>
    <url>%2F2019%2F11%2F20%2FSearch%2F</url>
    <content type="text"><![CDATA[检索 假设$k_{1},k_{2}……,k_{n}$是互不相同的关键码值，有一个包含n条记录的集合C，形式如下$(k_{1},I_{1}),(k_{2},I_{2}),……,(k_{n},I_{n})$。其中I_{j}是与关键码值绑定的value 匹配分类精确匹配：检索关键码值与某个特定值匹配的记录范围查询：检索关键码值在某个指定范围内得到所有记录 检索算法顺序表和线性表方法顺序查找和折半查找顺序查找的时间性能： 等概率$ASL_{ss}=$ 不等概率 二分检索法将dataList[i].Key与给定值K作比较三种情况 Key=K,检索成功 返回dataList[i] Key&gt;K,则改为查找dataList[i]的前半个表中查找 Key&lt;K,则改为查找dataList[i]的后半个表中查找 散列：理想情况下O(1) 树索引：启发式规则：初始序列：ABCDEFGH访问模式：FDFGEGFADF 计数统计方法保持线性表按照访问频率排序：A(1)B(0)C(0)D(2)E(2)F(4)G(3)H(0) 排序后：FGDEABCH 移至前端访问某条记录，将该记录移至前端（刚访问过的元素很可能再被访问）F:FABCDEGHD:DFABCEGHF:FDABCEGHG:GFDABCEHE:EGFDABCH…ANSWER:EGFDABCH 转置将当前访问的记录与它在线性表中的前一条记录交换位置(访问某个元素，将其在线性表中的位置前移一位) 与‘移至前端’原理类似 哈希表哈希函数 Key-position映射]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graph]]></title>
    <url>%2F2019%2F11%2F15%2FGraph%2F</url>
    <content type="text"><![CDATA[图论V表示点 E表示边 图的两种常见实现方式：1.邻接矩阵2.邻接表 邻接矩阵Edge[n][n]则约定Edge[i][j]仅在 节点i与节点j之间有连线时候为1（有向图和无向图略有区别…无向图有联系即为双向，所以会把Edge[i][j]与Edge[j][i]均置为1，有向图则根据指向置为1） 邻接表无向图：简单来说就是图中每一个点拥有一个自己的链表，这个链表以自己为头结点，链表中其他的节点都是头结点的邻居点dest邻居link指向下一个邻居 有向图：有向图因为具有方向性，所以使用两个邻接表来分别表示某节点的出边和入边。出边表：第i个链表，是以该链表头结点为起点发出的边，指向各个邻居入边表：第i个链表，是以该链表头结点为终点的边，从各个邻居发出，在该头节点结束 术语有向图：边具有方向性，边限定从一个顶点指向另一个顶点尖括号&lt;&gt;表示顶点偶对:&lt; v1,v2 &gt;和&lt; v2,v1 &gt;表示两个不同的边 无向图：边无方向性圆括号()表示顶点偶对：( v1,v2 )和( v2,v1 )表示同一个边 稀疏图，密集图：边数的多少 完全图：若有n个顶点的无向图有n(n-1)/2条边，则此图为无向图（所有顶点两两之间都有边相连接）若有n个顶点的有向图有n(n-1)/2*2=n(n-1)条边，则此图为有向完全图（所有顶点两两之间都有边相连接） 邻接顶点：如果(u,v)是E(G)中的一条边，则称u和v互为邻接顶点权：某些图的边具有与之相关数，成为边的权.这种带权图称为网络 子图：设有两个图G=(V,E)，设有两个图G＝( V,E )和G‘＝( V’,E’)。若 V’属于V且 E’属于E , 则称图G’是图G的子图。即 拿出一个图中的某一些点和某一些边作为一个图（类比子集和全集） 顶点的的度：一个顶点的度是与他相连关联的边的条数。记作TD(v) 在有向图中，定点的度等于该顶点的出度与入度之和（虽然入度与出度的值一正一负来区分，但是这里是绝对值求和） 顶点v的入度和出度：入度：以v为终点的有向边的条数出度：以v为起点的有向边的条数 路径：在图 G＝(V, E) 中, 若从顶点v_{i}出发, 沿一些边经过一些顶点 v_{p1},v_{p2},…,v_{pm}到达顶点v_{j} 。则称顶点序列 ( v_{i} v_{p1} v_{p2} ... v_{pm} v_{j} ) 为从顶点v_{i} 到顶点v_{j}的路径。它经过的边(v_{i} , v_{p1})、(v_{p1} , v_{p2})、...、(v_{pm} , v_{j})应是属于E的边。 路径长度非带权图的路径长度是指此路径上边的条数。带权图的路径长度是指路径上各边的权之和 简单路径若路径上各顶点 v_{1} , v_{2} ,..., v_{m} 均不互相重复, 则称这样的路径为简单路径。回路若路径上第一个顶点v_{1} 与最后一个顶点v_{m} 重合,则称这样的路径为回路或环。 极大连通子图和极小连通子图的定义及讲解极大连通子图，极小连通子图分量，显然是可能存在多个的但是若是极大连通子图，表征了其不应该被其他分量所包含（如果真有，那么就应该是那位来当极大连通子图了）极小连通子图类比补充：强连通图只有一个强连通分量，即本身。 连通图与连通分量在无向图中, 若从顶点v_{1}到顶点v_{2}有路径, 则称顶点v_{1}与v_{2}是连通的。如果图中任意一对顶点都是连通的, 则称此图是连通图。非连通图的极大连通子图叫做连通分量 强连通图与强连通分量在有向图中, 若对于每一对顶点v_{i} 和v_{j} , 都存在一条从v_{i} 到v_{j} 和从v_{j} 到v_{i} 的路径, 则称此图是强连通图。非强连通图的极大强连通子图叫做强连通分量。 生成树一个连通图的生成树是它的极小连通子图，在n个顶点的情形下，有n-1条边。但有向图则可能得到它的由若干有向树组成的生成森林。 不讨论的图（课程） 图的遍历从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历 ( Graph Traversal )。 图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。 为了避免重复访问，可设置一个标志顶点是否被访问过的标志位，它的初始状态为 0，在图的遍历过程中，一旦某一个顶点 i被访问，就立即让该顶点标志位为 1，防止它被多次访问。 DFS（一直往前走，直到走不通）栈实现从深度优先搜索遍历连通图的过程来看，类似于树的先根遍历； 邻接表表示时，查找所有顶点的邻接点所需时间为O(E)，访问顶点的邻接点所花时间为O（V）,此时，总的时间复杂度为O(V+E)。 邻接矩阵表示时，查找每个顶点的邻接点所需时间为O(V)，要查找整个矩阵，故总的时间度为O(V^2)。 v为图的顶点数，E为边数。 BFS队列实现（水面上滴一滴水，中心逐层向外扩展）邻接表形式存储时，每个顶点均需搜索一次，时间复杂度T1=O（v），从一个顶点开始搜索时，开始搜索，访问未被访问过的节点。最坏的情况下，每个顶点至少访问一次，每条边至少访问1次，这是因为在搜索的过程中，若某结点向下搜索时，其子结点都访问过了，这时候就会回退，故时间复 杂度为O(E)，算法总的时间复 度为O(|V|+|E|)。 邻接矩阵存储方式时，查找每个顶点的邻接点所需时间为O(V)，即该节点所在的该行该列。又有n个顶点，故算总的时间复杂度为O(|V|^2)。 有向图的拓扑排序例：大学生的专业培养计划（学习概率论的基础是高数1和高数2，即前置课程） 定义AOV网——用顶点表示活动，用弧表示活动间优先关系的有向图称为顶点表示活动的网(Activity On Vertex network)，简称AOV网，若&lt; vi,vj &gt;是图中有向边，则vi是vj的直接前驱；vj是vi的直接后继AOV网中不允许有回路，这意味着某项活动以自己为先决条件 拓扑排序把AOV网络中各顶点按照它们相互之间的优先关系排列成一个线性序列的过程 检测AOV网中是否存在环方法：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环（） 拓扑排序的方法 在有向图中选一个没有前驱的顶点且输出之 从图中删除该顶点和所有以它为起点的弧 重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止即：当前可以进入排序序列的节点一定符合条件：其没有前驱节点（要么是十分基础的课程，没有前置课程就能开始学习；要么就是其前置课程已经学习完毕，可以开始学习该课程） Kruskal 算法Kruskal 算法也是一个简单的贪心算法考虑问题的出发点为使得生成树的权值和最小，则应尽量使得每条加入生成树的边尽可能小 首先，将顶点集分为|V| 个等价类，每个等价类包括一个顶点 然后，以权的大小为序处理各条边。如果某条边连接两个不同等价类的顶点，则这条边被加入MST ，两个等价类也被合为一个3.反复执行此过程直至只余下一个等价类。 Kruskal 算法的关键技术:对边(权)进行贪心 取权值最小的边首先对边进行完全排序，使用最小值堆来实现，一次取一条边。实际上在完成MST 前仅需访问一小部分边。 确定两个顶点是否属于同一等价类可以用树的基于父指针表示法的UNION/FIND算法，可以看树post里关于并查集的介绍 例子：]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1090]]></title>
    <url>%2F2019%2F11%2F10%2FLuoguP1090%2F</url>
    <content type="text"><![CDATA[P1090 合并果子水题 (๑•̀ㅂ•́)و✧ 优先队列 直接贪心从头来过… #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;fruit; int main() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { int weight; cin&gt;&gt;weight; fruit.push(weight); } int ans=0; while(fruit.size()!=1) { int w1,w2; w1=fruit.top(); fruit.pop(); w2=fruit.top(); fruit.pop(); ans+=w1+w2; fruit.push(w1+w2); } cout&lt;&lt;ans; return 0; }]]></content>
      <tags>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Greedy]]></title>
    <url>%2F2019%2F11%2F10%2FGreedy%2F</url>
    <content type="text"><![CDATA[贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关 P1090 合并果子优先队列（使用stl写好的priority_queue）先出队列元素不是先进队列的元素，而是队列中优先级最高的元素代码 priority_queue基本用法： //升序队列 push小的优先 小的在堆顶 priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //降序队列 push大的优先 大的在堆顶 也是默认情况 priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q; struct node{ int x; bool operator&lt;(const tmp1&amp; a) const { return x &lt; a.x; // this object 的优先级 小于 a的优先级 } }]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BinSearchTree]]></title>
    <url>%2F2019%2F11%2F10%2FBinSearchTree%2F</url>
    <content type="text"><![CDATA[二叉检索树二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。可以实现字典的功能，通过将关键码与值绑定（可以将不可比较大小的值，变得可比，大概～(￣▽￣～)(～￣▽￣)～）二分检索树的时间复杂度为\theta (\log n) 插入操作key值如果小于当前节点的k值，往右边深入，否则往左边深入，直到成为叶子节点 删除操作step1:deletemin()//删除树中的最小值根据树的特性，一直向左子树深入，知道某个节点没有左子节点，则该节点为树中最小节点.则欲删除该节点，只需使其父节点的leftChild指针 直接指向该节点的右子树，即可完成删除.且不破坏BST树的结构（其父节点一定大于等于其左子树中各节点） step2:1.如果要删除的节点R没有子节点，那么只需要把其父节点指向R的指针，指向NULL即可2.如果要删除的节点R只有一个子节点，那么只需要把其父节点指向R的指针，指向R唯一的一颗子树即可3.如果要删除的节点R有两个子节点，较好地解决办法是从某棵子树中，找出一个R的替代者替代者的选取：大于(或等于)被替换值的最小者]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman]]></title>
    <url>%2F2019%2F11%2F09%2FHuffman%2F</url>
    <content type="text"><![CDATA[Huffman树设根树T有t片树叶v_{1},v_{2},..,v_{t},给每片树叶赋一个权值w_{1},w_{2},...,w_{t},则成为T赋权二叉树，其中l(v_{i})为叶子节点v_{i}的长度（节点到根节点路径长度），如果存在一种赋权方式，使得\sum_{i=1}^{t}w_{i}l(v_{i})的值（带权路径和）达到最小，则称这棵树为最优二叉树，或称Huffman树. 构造方法(1).对所有权值从低到高排序.(2).找出两个最小的权值，记为w_{1},w_{2}(3).用(w_{1}+w_{2} 代替w_{1}与w_{2}),产生新的队列(4).若队列中的点数大于1，则回到第一步，否则进行下一步. (5).逆序将以上组合过程画出来得到Huffman树 注意点构造时为保证唯一性，要求”左小右大，组合优先，左0右1，不足补0”左小右大：值权值小的画左边，权值大的画右边组合优先：如果某两个权值相同，则组合出来的节点优先（作为左子节点，画在左边）左0右1：是指向左儿子的边的编号为0， 指向右儿子的边编号为1不足补零：译码时使用，在末尾添加适当0以使得可以译码码]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1162]]></title>
    <url>%2F2019%2F11%2F09%2FLuoguP1162%2F</url>
    <content type="text"><![CDATA[模板题目：和Leetcode T130的解法只需要改一下参数就可 #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; using namespace std; void DFS(int r,int c,vector&lt;vector&lt;char&gt; &gt;&amp; board) { if(r&lt;0||r&gt;=board.size()||c&lt;0 ||c&gt;=board[0].size()||board[r][c]==&#39;1&#39; ||board[r][c]==&#39;H&#39;) { return ; } board[r][c]=&#39;H&#39;; DFS(r+1,c,board); DFS(r-1,c,board); DFS(r,c+1,board); DFS(r,c-1,board); } void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) { if(board.size()&lt;1||board[0].size()&lt;1) return ; for(int i=0;i&lt;board[0].size();i++) DFS(0,i,board); for(int i=0;i&lt;board[0].size();i++) DFS(board.size()-1,i,board); for(int i=0;i&lt;board.size();i++) DFS(i,0,board); for(int i=0;i&lt;board.size();i++) DFS(i,board[0].size()-1,board); for(int i=0;i&lt;board.size();i++) { for(int j=0;j&lt;board[0].size();j++) { if(board[i][j]==&#39;H&#39;) board[i][j]=&#39;0&#39;; else{ if(board[i][j]==&#39;0&#39;) board[i][j]=&#39;2&#39;; } } } } int main() { int n; cin&gt;&gt;n; vector&lt;vector&lt;char&gt; &gt;board; vector&lt;char&gt;temp; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { char ch; cin&gt;&gt;ch; temp.push_back(ch); } board.push_back(temp); temp.erase(temp.begin(),temp.end()); } solve(board); for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(j==0) cout&lt;&lt;board[i][j]; else{ cout&lt;&lt;&#39; &#39;&lt;&lt;board[i][j]; } } if(i!=n-1) cout&lt;&lt;endl; } return 0; } 真就是只改了下参数。。。。水题]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode127]]></title>
    <url>%2F2019%2F11%2F09%2FLeetcode127%2F</url>
    <content type="text"><![CDATA[思路分析转化为图来做两节点能转化，说明两节点连通，所以该问题变成，求图中begin节点和end节点是否可达，可达的最短路径求解1.建图2.BFS遍历图 class Solution { public: map]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode130]]></title>
    <url>%2F2019%2F11%2F08%2FLeetcode130%2F</url>
    <content type="text"><![CDATA[130.被围绕的区域被围绕的区域.题目还是很简单的：就沿着边沿做几次DFS，把所有和边沿连同的路径上的’O’标记出来，剩下的’O’就是被包围起来的，将其翻转为’X’即可 class Solution { public: void DFS(int r,int c,vector]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1141]]></title>
    <url>%2F2019%2F11%2F08%2FLuoguP1141%2F</url>
    <content type="text"><![CDATA[P1141 01迷宫题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入格式第1行为两个正整数n,m 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 输出格式m行，对于每个询问输出相应答案。 输入输出样例输入 2 2 01 10 1 1 2 2 输出 4 4 先分析一下，可以发现，对于某一种遍历方式，所经过的节点都共享该遍历方式；（无论从哪一点出发，总会按照该方式遍历迷宫）并且很容易知道，某点有且仅有一种遍历迷宫方式（因为每种方案总是完全的） 所以可以少算很多点，打表做 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream using namespace std; int n,m,ans[100002],x,y,node[1002][1002]; char s[1002][1002]; void dfs(int row,int col,int val,int index){ if (row&lt;0 || row&gt;=n || col&lt;0 || col&gt;=n || node[row][col]!=-1/*已经被一种方案遍历过*/ || s[row][col]-&#39;0&#39;!=val) return; node[row][col]=index;//路径上的点指向同一answer,共享答案 ans[index]++;//改节点为ans[index]贡献一个节点数 dfs(row-1,col,!val,index); dfs(row+1,col,!val,index); dfs(row,col-1,!val,index); dfs(row,col+1,!val,index); } int main() { cin&gt;&gt;n&gt;&gt;m; for (int i=0;i&lt;n;i++) scanf(&quot;%s&quot;,s[i]); memset(node,-1,sizeof(node)); for(int i=0;i&lt;m;i++) { cin&gt;&gt;x&gt;&gt;y; x--; y--; if (node[x][y]==-1) dfs(x,y,s[x][y]-&#39;0&#39;,i); else ans[i]=ans[node[x][y]]; } for (int i=0;i&lt;m;i++) cout&lt;&lt;ans[i]&lt;&lt;endl; return 0; }]]></content>
      <tags>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFSandDFS]]></title>
    <url>%2F2019%2F11%2F07%2FBFSandDFS%2F</url>
    <content type="text"><![CDATA[BFSandDFSa)迷宫求解（最少步数）b)水池数目(NYOJ27)c)图像有用区域(NYOJ92)d)树的前序中序后序遍历 DFS深度优先搜索上例子寻找二叉树上从根结点到给定结点的路径： 一.递归实现/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: stack&lt;TreeNode*&gt;P,Q; bool PFlag=false,QFlag=false; void DFS(TreeNode* root, TreeNode* goal,stack&lt;TreeNode*&gt;&amp;road,bool&amp;HasFind) { /*对树DFS寻找两个目标节点，然后存储路径，仅为寻找到最近的共同祖先（要不然root就是所有的祖先，那还找啥）*/ if(HasFind)//已经在别的地方找到了 return; if(root==goal)//现在刚刚找到 { HasFind=true;//flag置为1 road.push(root); return; } road.push(root); if(root-&gt;left)//DFS非空左子树 { DFS(root-&gt;left,goal,road,HasFind); if(!HasFind) road.pop();//子树中未找到目标节点，还原路径 } if(root-&gt;right)//DFS非空右子树 { DFS(root-&gt;right,goal,road,HasFind); if(!HasFind) road.pop();//子树中未找到目标节点，还原路径 } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { DFS(root,p,P,PFlag); DFS(root,q,Q,QFlag); stack&lt;TreeNode*&gt;Proad,Qroad; while(!P.empty()) { Proad.push(P.top()); P.pop(); } while(!Q.empty()) { Qroad.push(Q.top()); Q.pop(); } P=Proad; Q=Qroad; int MAXSize=P.size(); if(MAXSize&lt;Q.size()) { MAXSize=Q.size(); } TreeNode* temp=root; while(1) { if(P.empty()||Q.empty()) break; if(P.top()==Q.top()) { temp=P.top(); P.pop(); Q.pop(); }else break; } return temp; } }; 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 写这个题的时候，额。。。没看树的类型，直接敲了树的DFS，其实可以利用二叉检索树的特性的，服了，算了，反正目的达到了。下回有机会再写吧。 非递归实现BFSLeetcode 127.解法. 题目给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。说明: 如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] 输出: 5 解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, 返回它的长度 5。示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] 输出: 0 解释: endWord “cog” 不在字典中，所以无法进行转换。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-ladder著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProcessOfEquivalentPair]]></title>
    <url>%2F2019%2F11%2F06%2FProcessOfEquivalentPair%2F</url>
    <content type="text"><![CDATA[连通区域标记－行程扫描算法— 等价对的处理过程将等价对转换为若干个等价序列,比如有如下等价对: 只要两个数在同一序偶中，就用线连起来，化成一棵树经过等价对处理之后,应得到的等价序列为: list1:1-2-5-6-8-10-11-12-13-14-15 list2:3-7-9 list3:4 主要思路:将1-15个点都看成图的节点,而等价对说明节点1和2之间有通路,而且形成的图是无向图.我们需要遍历图,找到其中的所有连通图,主要采用的是图的深度优先遍历法,进行等价序列的查找. 如上图所示,从节点1开始查找,它有三个路径1-2,1-6,1-8;2和6后面没有路径,8后面有两个路径8-10,8-11;10后面没有路径,11后面有5条路径分别为11-5,11-12,11-13,11-14,11-15,到此,等价表1查找完毕. 等价表2是从3开始查找,它的后面有两条路径3-7,3-9. 等价表3只有一个孤立的点. 并查集父节点表示法对于树中的每个结点都保存一个指针域指向父结点。（缺点：不能准确地找到给定的结点的子结点信息。优点：可以解决判断俩个结点是否在同一个树中的问题；用并查算法合并俩个集合。） 基本操作查询元素a和元素b是否属于同一组：由于采用父节点表示法，使用递归，一直向上检索，判断两个节点能否走到同一个根（查询是否有共同祖先祖先），即可知道是否在一组中。 在下图，2和5都走到了1，因此他们为同一组。另一方面，由于7走到的是6，因此与2和5属于不同组 合并元素a和元素b所在的组：像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树，也就是把两个组合并为了一个组。将其中一颗树的根节点作为另一颗树的子节点： 并查集实现中的注意点(优化)(降低rank）退化问题在树形数据结构中，如果发生了退化的情况，那么复杂度就会变得很高。因此有必要避免退化（呈线性，树形结构不明显，丧失树形优势）1.对于每棵树，记录这棵树的高度（rank）2.合并时如果两个数的rank不同，那么从rank小的向rank大的连边。（大的连在小rank树上，会在大rank基础上增加深度；小的连在大的上，就可能会被包含，并不增加rank） 路径压缩不论是所查询的节点，还是在查询过程中向上经过的其他所有节点，都直接改为直接连到根上。这样再次查询这些节点时，就可以很快知道根是谁了。（降低rank）]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BasicAlgorithm]]></title>
    <url>%2F2019%2F11%2F02%2FBasicAlgorithm%2F</url>
    <content type="text"><![CDATA[一些板子 一些基本算法位运算左移variable = variable &lt;&lt; numvariable &lt;&lt;=num观察可以发现，左移一位的结果就是原值乘2，左移两位的结果就是原值乘4。右移variable = variable &gt;&gt; numvariable &gt;&gt;=num右移一位的结果就是原值除2，左移两位的结果就是原值除4，注意，除了以后没有小数位的，都是取整。按位与：字面意思variable &amp; 1 -&gt; 拿到最低位的数字variable &amp; 00000001 -&gt;0000000a 快速积(取模)精髓：化乘法为多次加法FastSpeedMultiplying typedef long long int ll; ll Mulitply(ll a,ll b,ll c) { ll ans=0; while(b) { if(b&amp;1) ans= (ans+a)%c; a= (a&lt;&lt;1)%c; //感觉还是可能会在a+a做加法的时候溢出，必要的时候做一个 (a mod c + a mod c)mod c b&gt;&gt;=1; } return ans; } 快速幂(取模)战神级讲解 ll Quick_Power(ll a,ll b,ll c) { ll ans=1; while(b) { if(b&amp;1) ans= Mulitply(ans,a,c); a=Mulitply(a,a,c); b&gt;&gt;=1; } return ans; } a)欧几里德算法求最大公约数 实现一：#include &lt;iostream&gt; using namespace std; int gcd(int m, int n) { int r = 0; while(n!=0) { r=m%n; m=n; n=r; } return m; } int main() { int m,n; cout&lt;&lt;&quot;请输入2个正整数：&quot;&lt;&lt;endl; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;endl&lt;&lt;&quot;最大公约数为：&quot;&lt;&lt;gcd(m,n)&lt;&lt;endl; return 0; } 实现二：int gcd(int a,int b) {//b是上一层的余数 a%b是这一层的余数 a是除数 return b==0?a:( gcd(b,a%b) ); } b)筛法求素数（朴素筛和快速线性筛）埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。为啥终止是根号n呢， 首先我们要明确，假设一个合数x能表示为两个数的乘积，他必定有一个小于等于sqrt(x)的因子，这可以用归谬证明法证明。如果两个因子都大于sqrt(x)，那么乘积大于x,这和假设矛盾。 然后就是，根据埃氏筛的思想，拿到当前序列的第一个新的素数，然后往后遍历筛选。因而对于序列较后面的数，在小于等于根号n的范围内总有机会被 其小于等于sqrt(x)的因子 筛一次（如果这个数真是合数的话），进而被筛去 大致过程：(1).把2到n的自然数放入a[2]到a[n]中(所放入的数与下标号相同) ; (2).在数组元素中以下标为序，按顺序找到未曾找过的最小素数minp和它的位置p(即下标号); (3).从p+1开始，把凡是能被minp整除的各元素值从a数组中划去(筛掉)，也就是把该元素标记为0;举个例子：minp=3 就把 3*3 3*4 3*5….筛掉，即PrimeFlag标记为0，is not a prime（也是缺点来源） 至于为什么从minp*minp开始筛:不需要从i*j（且j &lt; i）开始，因为i*j，在遇到j时已经被标记了，因为j比i小，所以遇到j比遇到i要早。同时因为从i*i开始标记，所以i终止条件也为sqrt(n)，否则i*i将大于n。（算是第二个方面限制i的范围在根号n内吧） (4).让p=p+1，重复执行第(2) (3)步骤，知道，minp&gt;floor(sqrt(n))为止; (5).打印输出a数组中留下来的数，未被筛掉的各元素值; int isPrime_sieve(int n){ int* isPrimes = (int*)malloc(sizeof(int)*(n+1)); int i,j; int sqrtn = sqrt(n); if(n&lt;=1) return 0; for(i=2;i&lt;=n;i++){ //初始化都为素数 isPrimes[i] = 1; } //从2开始，将素数的倍数标记为非素数 //从i的平方开始标记即可，不需要从i*j(且j&lt;i)开始，因为i*j至少在遇到j时已经被标记过了 for(i=2;i&lt;=sqrtn;i+=1){ if(isPrimes[i]==0) //不是素数，说明i可以分解为两个因子相乘，那么在遇到这两个因子的较小者时，i的倍数已经被标记过 continue; for(j=i*i;j&lt;=n;j+=i){ //j是i的倍数 isPrimes[j] = 0; } } return isPrimes[n]; } 这种求素数的算法很容易被理解，其时间复杂度介于O(n)~O(nlogn)是一种比较流行的方法。但是同样的，这种算法也存在先天性的缺陷，我们简单分析：对于一个数30，可分解为30=2*15=3*10=5*6，显然，当循环,2,3,5,6,10,15时都会筛除一次30这个数，而当n很大时，就会出现许多的冗余操作， 快速线性筛：(1).开一个n+1大小的数组num[]来存放每一个元素的筛留情况(num[i]用来表示i这个数是不是素数对于任意num[i] 有num[i]=0,num[i]=1两种情况，如果num[i]=0则是素数，反之num[i]=1时是合数); (2).再开一个数组prime[n]来存放筛出的素数以便最后输出结果; (3).对于一个数i,总是进行从i*prime[0]~i*prime[j](由小到大来乘)，直到if(i%prime[j]==0)成立时break掉 对（3）解释一下：第一，所有数（2~n）都会被作为i拿来判定，即第一层循环第二，为什么是从i*prime[0]~i*prime[j](由小到大来乘) 前提是：一个合数 i=p1*p2*…*pn, pi都是素数（2&lt;=i&lt;=n）,pi&lt;=pj ( i&lt;=j )p1是最小的系数。这样每一个合数就有一个确定的表示方法，不会重复。（像12=223）No.1：我们现在规定一个合数由两个数得到。NO.2：那么合数有两种。1.素数*素数=合数2.一个最小的素数*合数=合数 至于为什么if(i%prime[j]==0)成立时break掉 我们约定一下：记作 c*i而 c=a*b（b为c的最小质因数），按照结论，对于c这一组，只应当把i的值取到b因为假如取到了b+1 记为d=b+1, 则 迭代到 c*d而c=a*b 故 迭代到了 a*b*d 即 a*d*b -&gt; c’*b因而c*d==c’*b 这个数被多次判定 造成冗余 举个例子，对于一个数9，9*2=18将18标记为合数，循环继续；9*3=27将27标记为合数，此时发现9%3=0，循环退出。如果将循环继续下去会出现筛除9*5=45的情况，会对45进行一次筛选，而45=15*3，在15时会被在筛去一次，故不可行 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;ctime&gt; #include&lt;cmath&gt; #define inf 20000005 using namespace std; int n; bool a[inf+1]; bool num[inf+1]={1,1}; int prime[inf+1]={0},number=0; //number 记录素数个数 void putongshaifa() //普通筛法求素数 { clock_t begin,end; begin=clock(); for(int i=0;i&lt;=n;++i) a[i]=true; //初始化 全是素数 a[1]=false; //1不是素数 for(int i=2;i&lt;sqrt(n);++i) if(a[i])//新的第一个素数 for(int j=2;j&lt;=n/i;++j) a[i*j]=false; //i*1 i*2 i*3...一直往后筛 end=clock(); /*for(int i=2,t=0;i&lt;=n;++i) if(a[i]) { cout&lt;&lt;i&lt;&lt;&quot; &quot;; ++t; if(t%10==0) cout&lt;&lt;endl; } cout&lt;&lt;endl;*/ printf(&quot;普通筛法-Time used:%d ms\n&quot;,end-begin); return; } void kuaisushaifa() //快速筛法求素数 { clock_t begin,end; begin=clock(); for(int i=2;i&lt;=n;++i) //遍历所有2~n数 -&gt;i { if(!num[i]) prime[number++]=i; /*先用number的值再自加*/ for(int j=0;j&lt;number &amp;&amp; i*prime[j]&lt;=n;j++) { num[i*prime[j]]=1; //把所有合数标记为 1 if(!(i%prime[j]) /*i%prime[j]==0*/ ) // *为保证不重复筛选* break; } } end=clock(); /*for(int i=0;i&lt;number;i++) { if(i%10==0) printf(&quot;\n&quot;); printf(&quot;%3d&quot;,prime[i]); } */ printf(&quot;快速筛法-Time used:%d ms\n&quot;,end-begin); return; } int main() { //freopen(&quot;prime.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); int _test=10; while(_test--) { putongshaifa(); kuaisushaifa(); cout&lt;&lt;endl; } return 0; } #include&lt;iostream&gt; using namespace std; const int MAX=1000; bool IsPrime[MAX]; int Prime[MAX]; int main() { int n; cin&gt;&gt;n; int *a= new int[n+5]; for(int i=1;i&lt;=n;i++) { a[i]=i; IsPrime[i]=1; } int CurrPrime=0; IsPrime[1]=0; IsPrime[2]=1; for(int i=2;i&lt;=n;i++) { if(IsPrime[i]) { Prime[CurrPrime]=i; CurrPrime++; } for(int j=0;j&lt;CurrPrime&amp;&amp;i*Prime[j]&lt;=n;j++) { IsPrime[i*Prime[j]]=0; if(i%Prime[j]==0) { break; } } } for(int i=2;i&lt;=n;i++) { if(IsPrime[i]) { cout&lt;&lt;i&lt;&lt;&quot; is Prime\n&quot;; }else{ cout&lt;&lt;i&lt;&lt;&quot; is not a prime\n&quot;; } } return 0; } c)康托展开公式： rank = a_{n}\cdot(n-1)!+a_{n-1}\cdot(n-2)!+...+a_{1}\cdot 0!举例套用公式和理解：1,2,3,4的各个全排列按照字典序排列得到的rank 从0开始，即：（1234）的rank=0 其中，a_{i}的取值：先取在本排列中的第i位数字（最右边为第1位数字），在还未出现的元素中序列中，求出该数字的排名。 举个例子：（3214)\_{rank}= 2\*(4-1)!+1\*(4-2)!+0\*(4-3)!+0\*0!=14 设已经出现（或者说已经参与排列的元素）集合为S 初始化S={} 补集！S={1，2，3，4} 开始从给出的排列序列的最高位判断 3：处在3的位置，对应a_{3}的求解， 在！S中 元素3 大小排在第三位，a_{3}=3-1=2 （或者理解为！S中比3小的数字有2个） S={3} ！S={1，2，4} 2：处在2的位置，对应a_{2}的求解， 在！S中 元素2 大小排在第二位，a_{2}=2-1=1 （或者理解为！S中比2小的数字有1个） S={3，2} ！S={1，4} 1：处在1的位置，对应a_{1}的求解， 在！S中 元素1 大小排在第一位，a_{1}=1-1=0 （或者理解为！S中比1小的数字有0个） S={3，2，1} ！S={4} 4：处在0的位置，对应a_{0}的求解， 在！S中 元素4 大小排在第一位，a_{0}=1-1=0 （或者理解为！S中比4小的数字有0个） S={3，2，1，4} ！S={} 其实，最后一位的值不用判断总是取0，因为此时S中只会剩下这唯一一个元素 rank=14 最后，如果要求3214在全排列中排第几位，应当写 rank+1 = 15 d)逆康托展开辗转相除：（没有找到严谨的数学推理，先这样吧）还是上面的例子：3，2，1，4 rank=14 14 % (3!)=2...2 2 % (2!)=1...0 0 % (1!)=0...0 0 % (0!)=0...0 (最后一行同样不需要计算) 则还原过程： 初始化S={} 补集！S={1，2，3，4} 排名为2 +1：从！S中取出升序排列第3的数字：3 S={3} 补集！S={1，2，4} 排名为1 +1：从！S中取出升序排列第2的数字：2 S={3，2} 补集！S={1，4} 排名为0 +1：从！S中取出升序排列第1的数字：1 S={3，2，1} 补集！S={4} 排名为0 +1：从！S中取出升序排列第1的数字：4 S={3，2，1，4} 补集！S={} rank为14的序列为 3，2，1，4 e)同余定理两个整数除以同一个整数，若得相同余数，则二整数同余 数论中的一个重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，也读作a同余于b模m，记作a≡b(mod m)。对模m同余是整数的一个等价关系a=m*d+fb=m*e+f=&gt;(a-b)%m=(d-e)*m%m=d-e (假设a&gt;=b) 2019/11/7/21：32 to be continued… f)次方求模—快速幂(取模)算法对于普通类型的a_{n}求法是，自乘n次a 快速幂：1）当b是奇数时，那么有 a^{b}=a\cdot a^{b}2）当b是偶数时，那么有 a^{b}=a^{b/2}\cdot a^{b/2} 递归法：举个例子 2^{10}= (2^{\frac{10}{2}})^{2} 2^{5} = 2\cdot (2^{\frac{4}{2}})^{2}long long int binaryPow(long long int a, long long int b, long long int m){ if(b == 0) return 1; else if(b % 2 == 1) return a * binaryPow(a, b - 1, m) % m; else{ long long int num = binaryPow(a, b/2, m) % m; //优化 return num * num % m; // 不直接写成return binaryPow(a, b/2, m) * binaryPow(a, b/2, m) } } 迭代法：13=8*1+4*1+2*0+1*1 = 2^{3}*1+2^{2}*1+2^{1}*0+2^{0}*1 long long int binaryPow(long long int a, long long int b, long long int m){ long long int ans = 1; while(b &gt; 0){ if(b &amp; 1){//判断当前b的二进制位最低位 是否为1 从而提供乘的依据 ans = ans * a % m;//根据需要 是否乘2^{i} } a = a * a % m;//平方计数器 b &gt;&gt;= 1; //右移一位 } return ans; }]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearningPath]]></title>
    <url>%2F2019%2F11%2F02%2FLearningPath%2F</url>
    <content type="text"><![CDATA[http://history.ccfccsp.org.cn/临时路线. 需要掌握以下基本算法：a)欧几里德算法求最大公约数b)筛法求素数c)康托展开d)逆康托展开e)同余定理f)次方求模计算几何初步a)三角形面积b)三点顺序 学会简单计算程序的时间复杂度与空间复杂度二分查找法简单的排序算法a)冒泡排序法b)插入排序法贪心算法经典题目]]></content>
  </entry>
  <entry>
    <title><![CDATA[MaxHeap]]></title>
    <url>%2F2019%2F11%2F01%2FGensokyo%2F</url>
    <content type="text"><![CDATA[最大堆和最小堆最大堆和最小堆是二叉堆的两种形式。（完全二叉树） 最大堆：根结点的键值是所有堆结点键值中最大者，且每个结点的值都比其孩子的值大。 最小堆：根结点的键值是所有堆结点键值中最小者，且每个结点的值都比其孩子的值小。构建方式不唯一 下面对书本上的bulid过程分析并实现：（仅仅分析最大堆，则最小堆可以重载大于号等进行构建） 关键操作：siftdown(节点下沉、下拉) 构建的算法原理基础：归纳证明假设根的两个子树都是最大堆了，设根的元素为R，则有两种情况：一、R的值大于或者等于其两个子节点，此时最大堆结构完成二、否则，R与两个子节点中大的那一个交换位置，此时最大堆结构完成，或者重复第二步直到完成 为了使得子树已经是最大堆，则可以采用递归（我们不用），或者倒着循环上来下面采用循环实现BuildHeap： 初始化curr=HeapSize/2（最后一个分支节点，开始开倒车） BuildMaxHeap#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int a[1000]; void OrderPrint(int n) { int line=2; for(int i=1;i&lt;=n;i++) { cout&lt;&lt;&#39; &#39;&lt;&lt;a[i]&lt;&lt;&#39; &#39;; if(i==line-1) {// 1 3 7 cout&lt;&lt;endl; line*=2; } } } int main() { int n; cin&gt;&gt;n; memset(a,0,1000*sizeof(int)); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } int HeapSize=n; for(int curr=HeapSize/2;curr&gt;=1;curr--) { int son=curr*2;//son 其实可以理解为 变动元素的下一个待判断的位置 //a[0]=a[curr]; while(son&lt;=HeapSize)// //待判断的位置 的 上限 { if(a[son]&lt;a[son+1]) { son++; } if(a[son/2]&gt;=a[son]) {/*父节点大于最大子节点 堆结构 构造完成*/ break;//停止下沉 } else{//节点小于最大子节点 swap(a[son/2],a[son]);//父变子 子变父 son*=2;//待判断的位置 移动到下一层 } } } OrderPrint(HeapSize); return 0; } 插入：添加到数组尾部（n+1处）比较简单和其父节点比较一路 上浮 到合适的位置即可可以调用OrderPrint方法查看上浮全程（其实我拿来debug的，因为我这a[0]的元素会干扰，a[0]并非堆中的节点） void MaxHeapInsert(int element,int &amp; HeapSize) { HeapSize++; a[HeapSize]=element; int curr=HeapSize; while(curr/2&gt;0&amp;&amp;a[curr/2]&lt;a[curr]) { //OrderPrint(HeapSize); swap(a[curr/2],a[curr]); curr/=2;//节点上浮 //OrderPrint(HeapSize); } } 删除：最大堆的删除，只能删除堆的最大值（根节点）把最后一个元素移动到根节点来当老大，然后siftdown对堆重排 不写了，&lt;(*\￣▽￣*)/]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonNote]]></title>
    <url>%2F2019%2F10%2F27%2FpythonLearning%2F</url>
    <content type="text"><![CDATA[python的一些常用知识 lambda 排序 广播机制 lambda普通函数 12def fuc(x): return x\*x 匿名函数 1testFuc=lambda x:x*x 测试 12345print(fuc(5))print(testFuc(5))2525 多关键字排序123456arr=[('a',1),('b',5),('c',3),('d',3),('d',7),('e',2),('f',10)]arr=sorted(arr,key=lambda x:(x[1],x[0]))print(arr)[('a', 1), ('e', 2), ('c', 3), ('d', 3), ('b', 5), ('d', 7), ('f', 10)] 匿名函数：lambda x:(x[1],x[0])，规定了arr中的元组元素x，以x[1]作为第一关键字，x[0]为第二关键字，均为升序。对于数值类型，我们可以通过添加负号实现降序，如：lambda x :(x[1],-x[0])），其指定第二关键字为x[0]的相反数，实现降序。 广播机制numpy 矩阵与向量的运算 1234567891011121314151617181920212223242526272829303132333435363738import numpy as npmat=np.random.randint(1,10,size=(5,4))print(mat)vec=np.random.randint(1,10,size=(5,1))print(vec)print(mat/vec)vec=np.random.randint(1,10,size=(1,4))print(vec)print(mat/vec)形状为5x4的矩阵mat:[[9 1 4 2] [9 2 3 6] [3 2 4 4] [5 9 5 7] [2 8 6 1]]形状为5x1的向量vec:[[4] [4] [7] [4] [6]]mat/vec:mat的每一个列向量与vec逐元素相除[[2.25 0.25 1. 0.5 ] [2.25 0.5 0.75 1.5 ] [0.42857143 0.28571429 0.57142857 0.57142857] [1.25 2.25 1.25 1.75 ] [0.33333333 1.33333333 1. 0.16666667]] 形状为1x4的行向量vec:[[6 2 2 6]]mat/vec:mat的每一行向量与vec逐元素相除[[1.5 0.5 2. 0.33333333] [1.5 1. 1.5 1. ] [0.5 1. 2. 0.66666667] [0.83333333 4.5 2.5 1.16666667] [0.33333333 4. 3. 0.16666667]]]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
