<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ProcessOfEquivalentPair]]></title>
    <url>%2F2019%2F11%2F06%2FProcessOfEquivalentPair%2F</url>
    <content type="text"><![CDATA[连通区域标记－行程扫描算法— 等价对的处理过程将等价对转换为若干个等价序列,比如有如下等价对: 只要两个数在同一序偶中，就用线连起来，化成一棵树经过等价对处理之后,应得到的等价序列为: list1:1-2-5-6-8-10-11-12-13-14-15 list2:3-7-9 list3:4 主要思路:将1-15个点都看成图的节点,而等价对说明节点1和2之间有通路,而且形成的图是无向图.我们需要遍历图,找到其中的所有连通图,主要采用的是图的深度优先遍历法,进行等价序列的查找. 如上图所示,从节点1开始查找,它有三个路径1-2,1-6,1-8;2和6后面没有路径,8后面有两个路径8-10,8-11;10后面没有路径,11后面有5条路径分别为11-5,11-12,11-13,11-14,11-15,到此,等价表1查找完毕. 等价表2是从3开始查找,它的后面有两条路径3-7,3-9. 等价表3只有一个孤立的点. 并查集父节点表示法对于树中的每个结点都保存一个指针域指向父结点。（缺点：不能准确地找到给定的结点的子结点信息。优点：可以解决判断俩个结点是否在同一个树中的问题；用并查算法合并俩个集合。） 基本操作查询元素a和元素b是否属于同一组：由于采用父节点表示法，使用递归，一直向上检索，判断两个节点能否走到同一个根（查询是否有共同祖先祖先），即可知道是否在一组中。 在下图，2和5都走到了1，因此他们为同一组。另一方面，由于7走到的是6，因此与2和5属于不同组 合并元素a和元素b所在的组：像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树，也就是把两个组合并为了一个组。将其中一颗树的根节点作为另一颗树的子节点： 并查集实现中的注意点(优化)(降低rank）退化问题在树形数据结构中，如果发生了退化的情况，那么复杂度就会变得很高。因此有必要避免退化（呈线性，树形结构不明显，丧失树形优势）1.对于每棵树，记录这棵树的高度（rank）2.合并时如果两个数的rank不同，那么从rank小的向rank大的连边。（大的连在小rank树上，会在大rank基础上增加深度；小的连在大的上，就可能会被包含，并不增加rank） 路径压缩不论是所查询的节点，还是在查询过程中向上经过的其他所有节点，都直接改为直接连到根上。这样再次查询这些节点时，就可以很快知道根是谁了。（降低rank）]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BasicAlgorithm]]></title>
    <url>%2F2019%2F11%2F02%2FBasicAlgorithm%2F</url>
    <content type="text"><![CDATA[一些基本算法a)欧几里德算法求最大公约数 实现一：#include &lt;iostream&gt; using namespace std; int gcd(int m, int n) { int r = 0; while(n!=0) { r=m%n; m=n; n=r; } return m; } int main() { int m,n; cout&lt;&lt;&quot;请输入2个正整数：&quot;&lt;&lt;endl; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;endl&lt;&lt;&quot;最大公约数为：&quot;&lt;&lt;gcd(m,n)&lt;&lt;endl; return 0; } 实现二：int gcd(int a,int b) {//b是上一层的余数 a%b是这一层的余数 a是除数 return b==0?a:(gcd(b,a%b)); } b)筛法求素数（朴素筛和快速线性筛）埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。为啥终止是根号n呢， 首先我们要明确，假设一个合数x能表示为两个数的乘积，他必定有一个小于等于sqrt(x)的因子，这可以用归谬证明法证明。如果两个因子都大于sqrt(x)，那么乘积大于x,这和假设矛盾。 然后就是，根据埃氏筛的思想，拿到当前序列的第一个新的素数，然后往后遍历筛选。因而对于序列较后面的数，在小于等于根号n的范围内总有机会被 其小于等于sqrt(x)的因子 筛一次（如果这个数真是合数的话），进而被筛去 大致过程：(1).把2到n的自然数放入a[2]到a[n]中(所放入的数与下标号相同) ; (2).在数组元素中以下标为序，按顺序找到未曾找过的最小素数minp和它的位置p(即下标号); (3).从p+1开始，把凡是能被minp整除的各元素值从a数组中划去(筛掉)，也就是把该元素标记为0;举个例子：minp=3 就把 3*3 3*4 3*5….筛掉，即PrimeFlag标记为0，is not a prime（也是缺点来源） 至于为什么从minp*minp开始筛:不需要从i*j（且j &lt; i）开始，因为i*j，在遇到j时已经被标记了，因为j比i小，所以遇到j比遇到i要早。同时因为从i*i开始标记，所以i终止条件也为sqrt(n)，否则i*i将大于n。（算是第二个方面限制i的范围在根号n内吧） (4).让p=p+1，重复执行第(2) (3)步骤，知道，minp&gt;floor(sqrt(n))为止; (5).打印输出a数组中留下来的数，未被筛掉的各元素值; int isPrime_sieve(int n){ int* isPrimes = (int*)malloc(sizeof(int)*(n+1)); int i,j; int sqrtn = sqrt(n); if(n&lt;=1) return 0; for(i=2;i&lt;=n;i++){ //初始化都为素数 isPrimes[i] = 1; } //从2开始，将素数的倍数标记为非素数 //从i的平方开始标记即可，不需要从i*j(且j&lt;i)开始，因为i*j至少在遇到j时已经被标记过了 for(i=2;i&lt;=sqrtn;i+=1){ if(isPrimes[i]==0) //不是素数，说明i可以分解为两个因子相乘，那么在遇到这两个因子的较小者时，i的倍数已经被标记过 continue; for(j=i*i;j&lt;=n;j+=i){ //j是i的倍数 isPrimes[j] = 0; } } return isPrimes[n]; } 这种求素数的算法很容易被理解，其时间复杂度介于O(n)~O(nlogn)是一种比较流行的方法。但是同样的，这种算法也存在先天性的缺陷，我们简单分析：对于一个数30，可分解为30=2*15=3*10=5*6，显然，当循环,2,3,5,6,10,15时都会筛除一次30这个数，而当n很大时，就会出现许多的冗余操作， 快速线性筛：(1).开一个n+1大小的数组num[]来存放每一个元素的筛留情况(num[i]用来表示i这个数是不是素数对于任意num[i] 有num[i]=0,num[i]=1两种情况，如果num[i]=0则是素数，反之num[i]=1时是合数); (2).再开一个数组prime[n]来存放筛出的素数以便最后输出结果; (3).对于一个数i,总是进行从i*prime[0]~i*prime[j](由小到大来乘)，直到if(i%prime[j]==0)成立时break掉 对（3）解释一下：第一，所有数（2~n）都会被作为i拿来判定，即第一层循环第二，为什么是从i*prime[0]~i*prime[j](由小到大来乘) 前提是：一个合数 i=p1*p2*…*pn, pi都是素数（2&lt;=i&lt;=n）,pi&lt;=pj ( i&lt;=j )p1是最小的系数。这样每一个合数就有一个确定的表示方法，不会重复。（像12=223）No.1：我们现在规定一个合数由两个数得到。NO.2：那么合数有两种。1.素数*素数=合数2.一个最小的素数*合数=合数 至于为什么if(i%prime[j]==0)成立时break掉 我们约定一下：记作 c*i而 c=a*b（b为c的最小质因数），按照结论，对于c这一组，只应当把i的值取到b因为假如取到了b+1 记为d=b+1, 则 迭代到 c*d而c=a*b 故 迭代到了 a*b*d 即 a*d*b -&gt; c’*b因而c*d==c’*b 这个数被多次判定 造成冗余 举个例子，对于一个数9，9*2=18将18标记为合数，循环继续；9*3=27将27标记为合数，此时发现9%3=0，循环退出。如果将循环继续下去会出现筛除9*5=45的情况，会对45进行一次筛选，而45=15*3，在15时会被在筛去一次，故不可行 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;ctime&gt; #include&lt;cmath&gt; #define inf 20000005 using namespace std; int n; bool a[inf+1]; bool num[inf+1]={1,1}; int prime[inf+1]={0},number=0; //number 记录素数个数 void putongshaifa() //普通筛法求素数 { clock_t begin,end; begin=clock(); for(int i=0;i&lt;=n;++i) a[i]=true; //初始化 全是素数 a[1]=false; //1不是素数 for(int i=2;i&lt;sqrt(n);++i) if(a[i])//新的第一个素数 for(int j=2;j&lt;=n/i;++j) a[i*j]=false; //i*1 i*2 i*3...一直往后筛 end=clock(); /*for(int i=2,t=0;i&lt;=n;++i) if(a[i]) { cout&lt;&lt;i&lt;&lt;&quot; &quot;; ++t; if(t%10==0) cout&lt;&lt;endl; } cout&lt;&lt;endl;*/ printf(&quot;普通筛法-Time used:%d ms\n&quot;,end-begin); return; } void kuaisushaifa() //快速筛法求素数 { clock_t begin,end; begin=clock(); for(int i=2;i&lt;=n;++i) //遍历所有2~n数 -&gt;i { if(!num[i]) prime[number++]=i; /*先用number的值再自加*/ for(int j=0;j&lt;number &amp;&amp; i*prime[j]&lt;=n;j++) { num[i*prime[j]]=1; //把所有合数标记为 1 if(!(i%prime[j]) /*i%prime[j]==0*/ ) // *为保证不重复筛选* break; } } end=clock(); /*for(int i=0;i&lt;number;i++) { if(i%10==0) printf(&quot;\n&quot;); printf(&quot;%3d&quot;,prime[i]); } */ printf(&quot;快速筛法-Time used:%d ms\n&quot;,end-begin); return; } int main() { //freopen(&quot;prime.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); int _test=10; while(_test--) { putongshaifa(); kuaisushaifa(); cout&lt;&lt;endl; } return 0; } #include&lt;iostream&gt; using namespace std; const int MAX=1000; bool IsPrime[MAX]; int Prime[MAX]; int main() { int n; cin&gt;&gt;n; int *a= new int[n+5]; for(int i=1;i&lt;=n;i++) { a[i]=i; IsPrime[i]=1; } int CurrPrime=0; IsPrime[1]=0; IsPrime[2]=1; for(int i=2;i&lt;=n;i++) { if(IsPrime[i]) { Prime[CurrPrime]=i; CurrPrime++; } for(int j=0;j&lt;CurrPrime&amp;&amp;i*Prime[j]&lt;=n;j++) { IsPrime[i*Prime[j]]=0; if(i%Prime[j]==0) { break; } } } for(int i=2;i&lt;=n;i++) { if(IsPrime[i]) { cout&lt;&lt;i&lt;&lt;&quot; is Prime\n&quot;; }else{ cout&lt;&lt;i&lt;&lt;&quot; is not a prime\n&quot;; } } return 0; } c)康托展开公式： rank = a_{n}\cdot(n-1)!+a_{n-1}\cdot(n-2)!+...+a_{1}\cdot 0!举例套用公式和理解：1,2,3,4的各个全排列按照字典序排列得到的rank 从0开始，即：（1234）的rank=0 其中，a_{i}的取值：先取在本排列中的第i位数字（最右边为第1位数字），在还未出现的元素中序列中，求出该数字的排名。 举个例子：（3214)\_{rank}= 2\*(4-1)!+1\*(4-2)!+0\*(4-3)!+0\*0!=14 设已经出现（或者说已经参与排列的元素）集合为S 初始化S={} 补集！S={1，2，3，4} 开始从给出的排列序列的最高位判断 3：处在3的位置，对应a_{3}的求解， 在！S中 元素3 大小排在第三位，a_{3}=3-1=2 （或者理解为！S中比3小的数字有2个） S={3} ！S={1，2，4} 2：处在2的位置，对应a_{2}的求解， 在！S中 元素2 大小排在第二位，a_{2}=2-1=1 （或者理解为！S中比2小的数字有1个） S={3，2} ！S={1，4} 1：处在1的位置，对应a_{1}的求解， 在！S中 元素1 大小排在第一位，a_{1}=1-1=0 （或者理解为！S中比1小的数字有0个） S={3，2，1} ！S={4} 4：处在0的位置，对应a_{0}的求解， 在！S中 元素4 大小排在第一位，a_{0}=1-1=0 （或者理解为！S中比4小的数字有0个） S={3，2，1，4} ！S={} 其实，最后一位的值不用判断总是取0，因为此时S中只会剩下这唯一一个元素 rank=14 最后，如果要求3214在全排列中排第几位，应当写 rank+1 = 15 d)逆康托展开辗转相除：（没有找到严谨的数学推理，先这样吧）还是上面的例子：3，2，1，4 rank=14 14 % (3!)=2...2 2 % (2!)=1...0 0 % (1!)=0...0 0 % (0!)=0...0 (最后一行同样不需要计算) 则还原过程： 初始化S={} 补集！S={1，2，3，4} 排名为2 +1：从！S中取出升序排列第3的数字：3 S={3} 补集！S={1，2，4} 排名为1 +1：从！S中取出升序排列第2的数字：2 S={3，2} 补集！S={1，4} 排名为0 +1：从！S中取出升序排列第1的数字：1 S={3，2，1} 补集！S={4} 排名为0 +1：从！S中取出升序排列第1的数字：4 S={3，2，1，4} 补集！S={} rank为14的序列为 3，2，1，4 e)同余定理两个整数除以同一个整数，若得相同余数，则二整数同余 数论中的一个重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，也读作a同余于b模m，记作a≡b(mod m)。对模m同余是整数的一个等价关系a=m*d+fb=m*e+f=&gt;(a-b)%m=(d-e)*m%m=d-e (假设a&gt;=b) 2019/11/7/21：32 to be continued… f)次方求模]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearningPath]]></title>
    <url>%2F2019%2F11%2F02%2FLearningPath%2F</url>
    <content type="text"><![CDATA[临时路线. 需要掌握以下基本算法：a)欧几里德算法求最大公约数b)筛法求素数c)康托展开d)逆康托展开e)同余定理f)次方求模计算几何初步a)三角形面积b)三点顺序 学会简单计算程序的时间复杂度与空间复杂度二分查找法简单的排序算法a)冒泡排序法b)插入排序法贪心算法经典题目]]></content>
  </entry>
  <entry>
    <title><![CDATA[ShortestPath]]></title>
    <url>%2F2019%2F11%2F01%2FShortestPath%2F</url>
    <content type="text"><![CDATA[感慨：大一一年，奔波了不少地方，雨露均沾，我其实有些累了，团队合作开发一直是我所羡慕的，但是我一直没有做成一件项目，我理解大家都有各自的想法，我累了，我现在想自己走一走了临时路线. 最短路径：什么是最短路径？ 单源最短路径（所谓单源最短路径就是只指定一个顶点，最短路径是指其他顶点和这个顶点之间的路径的权值的最小值）什么是最短路径问题？ 给定一带权图，图中每条边的权值是非负的，代表着两顶点之间的距离。指定图中的一顶点为源点，找出源点到其它顶点的最短路径和其长度的问题，即是单源最短路径问题 非负这个条件很有意思，要是负数且形成环的话，你可以在这条路上不断刷。。。反正是负数 带权图的单源最短路径Floyd算法\Floyd-Warshall算法Floyd算法.有一说一，讲的可以ヾ(≧▽≦*)o简述一下：初始化图-&gt;加载各点的路径长（矩阵存储）-&gt;顺序引入新的中转点-&gt;遍历更新路径长的矩阵-&gt;继续引入继续更新 for(k=1;k&lt;=n;k++) {//迭代更新新的中转点 for(i=1;i&lt;=n;i++) {//两层循环 遍历更新 路径长度矩阵 的值 for(j=1;j&lt;=n;j++) { if(e[i][j]&gt;e[i][k]+e[k][j]) { e[i][j]=e[i][k]+e[k][j]; } } } } Dijkstra算法该算法使用的是贪心策略：每次都找出剩余顶点中与源点距离最近的一个顶点。参考：Dijkstra算法 算法思想带权图G=令S为已确定了最短路径顶点的集合，则可用V-S(V集合减去S集合)表示剩余未确定最短路径顶点的集合。假设V0是源点，则初始 S={V0}。用数组Distance表示源点V0到其余顶点的路径长度，用数组pre[i]表示最短路径序列上顶点i的前一个顶点。初始时，pre[i]都是源点的下标。接下来需重复两个步骤： 从当前Distance[i]找出最小的一个，记录其下标v=i，源点V0到顶点Vv的最短路径即已确定，把Vv加入S。更新源点到剩余顶点的最短路径长度。更新方法是：以上一步的顶点Vv为中间点，若Distance[v]+weight(v,i)小于Distance[i]，则修改值：pre[i]=v;Distance[i]=Distance[v]+weight(v,i);重复以上两个步骤，直至所有顶点的最短路径都已找到.。需要指出，Dijkstra算法求解的不仅是有向图，无向图也是可以的。下面给出一个完整的有向带权图的实例： SPFA算法\Bellman-Ford算法Johnson算法A*算法]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gensokyo]]></title>
    <url>%2F2019%2F11%2F01%2FGensokyo%2F</url>
    <content type="text"><![CDATA[不是我变化太大，只是预见了最后的可能分支。为了不被抛弃，更为了避免那时的无能狂怒，我只能选择，不辞而别，独自行走。 最大堆和最小堆最大堆和最小堆是二叉堆的两种形式。（完全二叉树） 最大堆：根结点的键值是所有堆结点键值中最大者，且每个结点的值都比其孩子的值大。 最小堆：根结点的键值是所有堆结点键值中最小者，且每个结点的值都比其孩子的值小。构建方式不唯一 下面对书本上的bulid过程分析并实现：（仅仅分析最大堆，则最小堆可以重载大于号等进行构建） 关键操作：siftdown(节点下沉、下拉) 构建的算法原理基础：归纳证明假设根的两个子树都是最大堆了，设根的元素为R，则有两种情况：一、R的值大于或者等于其两个子节点，此时最大堆结构完成二、否则，R与两个子节点中大的那一个交换位置，此时最大堆结构完成，或者重复第二步直到完成 为了使得子树已经是最大堆，则可以采用递归（我们不用），或者倒着循环上来下面采用循环实现BuildHeap： 初始化curr=HeapSize/2（最后一个分支节点，开始开倒车） BuildMaxHeap#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int a[1000]; void OrderPrint(int n) { int line=2; for(int i=1;i&lt;=n;i++) { cout&lt;&lt;&#39; &#39;&lt;&lt;a[i]&lt;&lt;&#39; &#39;; if(i==line-1) {// 1 3 7 cout&lt;&lt;endl; line*=2; } } } int main() { int n; cin&gt;&gt;n; memset(a,0,1000*sizeof(int)); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } int HeapSize=n; for(int curr=HeapSize/2;curr&gt;=1;curr--) { int son=curr*2;//son 其实可以理解为 变动元素的下一个待判断的位置 //a[0]=a[curr]; while(son&lt;=HeapSize)// //待判断的位置 的 上限 { if(a[son]&lt;a[son+1]) { son++; } if(a[son/2]&gt;=a[son]) {/*父节点大于最大子节点 堆结构 构造完成*/ break;//停止下沉 } else{//节点小于最大子节点 swap(a[son/2],a[son]);//父变子 子变父 son*=2;//待判断的位置 移动到下一层 } } } OrderPrint(HeapSize); return 0; } 插入：添加到数组尾部（n+1处）比较简单和其父节点比较一路 上浮 到合适的位置即可可以调用OrderPrint方法查看上浮全程（其实我拿来debug的，因为我这a[0]的元素会干扰，a[0]并非堆中的节点） void MaxHeapInsert(int element,int &amp; HeapSize) { HeapSize++; a[HeapSize]=element; int curr=HeapSize; while(curr/2&gt;0&amp;&amp;a[curr/2]&lt;a[curr]) { //OrderPrint(HeapSize); swap(a[curr/2],a[curr]); curr/=2;//节点上浮 //OrderPrint(HeapSize); } } 删除：最大堆的删除，只能删除堆的最大值（根节点）把最后一个元素移动到根节点来当老大，然后siftdown对堆重排 不写了，&lt;(*\￣▽￣*)/]]></content>
      <tags>
        <tag>Algorithm and Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pythonLearning]]></title>
    <url>%2F2019%2F10%2F27%2FpythonLearning%2F</url>
    <content type="text"><![CDATA[为了看懂Microsoft Speech Services API的源码，学习一下python的语法 python raise当程序出现错误，python会自动引发异常，也可以通过raise显示地引发异常。一旦执行了raise语句，raise后面的语句将不能执行 s = None if s is None: raise NameError print &#39;is here?&#39; 直接抛出异常，不会执行到这里 python 继承子类直接 son(farther) class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return &#39;Father &#39; + self.name class Son(Father): def getName(self): return &#39;Son &#39;+self.name str方法如果要把一个类的实例变成 str，就需要实现特殊方法str()：例子： 不使用str()方法class Student(object): def __init__(self,id,name,age): self.id=id self.name=name self.age=age s=Student(111,”Bob”,18)print(s)输出结果： main.Student object at 0x0362EBF0 使用str()方法class Student(object): def __init__(self,id,name,age): self.id=id self.name=name self.age=age def __str__(self): return &quot;学号:{}--姓名:{}--年龄{}&quot;.format(self.id,self.name,self.age) s=Student(111,”Bob”,18)print(s)输出结果：学号:111–姓名:Bob–年龄18 Python中的format方法类似printf()中的占位符print(“{}的性别是：{}”.format(“小明”,”男”))输出结果：小明的性别是：男 Python中的self指向类实例化后的对象，自己 Python中*args**kargs的用法总结先看一下固定参数的函数两输入加法函数def sum(x, y): z = x + y return zprint(sum(1,2)) 可变位置参数：*args 列表python中规定参数前带* 的，称为可变位置参数，只是我们通常称这个可变位置参数为*args,习惯和规范而已*args：是一个列表，传入的参数会被放进列表里。（c++建工程时创建的main函数的参数似乎也有，不太记得了，好像是用来接入命令行中的输入数据的，和这个有些类似，下回想起来了再说吧） def sum(\*args): ans = 0 for i in args: ans = ans + i print(ans) sum(1, 3, 5) 计算过程：ans=1+3+5 可变关键字参数：**kwargs 键值对同理，python中规定参数前 带 ** 的，称为可变关键字参数，通常用**kwargs表示。**kwargs：是一个字典，传入的参数以键值对的形式存放到字典里。 def test(**kwargs): print(kwargs) test(a=1,b=2,c=3) 运行结果：{‘a’: 1, ‘b’: 2, ‘c’: 3}]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicrosoftAPIReadingNotes]]></title>
    <url>%2F2019%2F10%2F27%2FMicrosoftAPIReadingNotes%2F</url>
    <content type="text"><![CDATA[azure-cognitiveservices-speech reference. 短促的字段识别（15s）start_continuous_recognition()]]></content>
      <tags>
        <tag>Microsoft Speech Services API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[step4-NonLinearRegression]]></title>
    <url>%2F2019%2F10%2F09%2Fstep4%2F</url>
    <content type="text"><![CDATA[https://www.codecogs.com/latex/eqneditor.php在线LaTeX公式编辑器 Step4 转载于Microsoft/ai-edu/blob/master/B-教学案例与实践最近赶进度，就不更了，有时间会把自己做的思考与练习题放在这里。 前向计算：输入 处理 输出误差计算：loss = predict - table反向传播|梯度下降 调整参数: 链式求导法则 9.3 双层神经网络实现非线性回归9.3.1 万能近似定理两层前馈神经网络（即一个隐层加一个输出层）和至少一层具有任何一种挤压性质的激活函数，只要隐层的神经元的数量足够，它可以以任意的精度来近似任何从一个有限维空间到另一个有限维空间的Borel可测函数。当然这个函数需要是单调递增有界的。注意，它要求的是挤压性质的激活函数，也就是类似Sigmoid的函数，如果用ReLU函数不能实现这个效果9.3.2 定义神经网络结构 输入层：一个标量X（自变量）输入层-隐藏层之间： 权重矩阵W1/B1 — 1行3列 W1= \begin{pmatrix} w^1_{11} & w^1_{12} & w^1_{13} \end{pmatrix} B1= \begin{pmatrix} b^1_{1} & b^1_{2} & b^1_{3} \end{pmatrix}隐层我们用3个神经元： Z1 = \begin{pmatrix} z^1_1 & z^1_2 & z^1_3 \end{pmatrix} A1 = \begin{pmatrix} a^1_1 & a^1_2 & a^1_3 \end{pmatrix}权重矩阵W2/B2W2的尺寸是3x1，B2的尺寸是1x1。 W2= \begin{pmatrix} w^2_{11} \\ w^2_{21} \\ w^2_{31} \end{pmatrix} B2= \begin{pmatrix} b^2_{1} \end{pmatrix}输出层由于我们只想完成一个拟合任务，所以输出层只有一个神经元：仅需得到一个因变量（Y） Z2 = \begin{pmatrix} z^2_{1} \end{pmatrix}9.3.3 前向计算隐层 线性计算 z^1_{1} = x \cdot w^1_{11} + b^1_{1} z^1_{2} = x \cdot w^1_{12} + b^1_{2} z^1_{3} = x \cdot w^1_{13} + b^1_{3} Z1 = X \cdot W1 + B1 \tag{1} 激活函数 a^1_{1} = Sigmoid(z^1_{1}) a^1_{2} = Sigmoid(z^1_{2}) a^1_{3} = Sigmoid(z^1_{3}) A1 = Sigmoid(Z1) \tag{2}输出层由于我们只想完成一个拟合任务，所以输出层只有一个神经元： z=a^1_{1}w^2_{11}+a^1_{2}w^2_{21}+a^1_{3}w^2_{31}+b^2_{1}矩阵形式： Z=A1 \cdot W2+B2 \tag{3}损失函数均方差损失函数： loss(w,b) = \frac{1}{2} (z-y)^2 \tag{4}s其中，$z$是样本预测值，$y$是样本的标签值，这里的z是第二层的输出Z。 回忆之前的简单模型，输入-&gt;单层神经元处理（线性计算+sigmoid）-&gt;输出Z1和Z 如果从局部来看，都是输出。只是Z1经过sigmoid处理后得到A再作为下一层的输入如下图|本章的神经网络|||第5章的神经网络||| 根据公式4： {\partial loss \over \partial z} = z - y \tag{5}求W2的梯度根据公式3和W2的矩阵形状： dW2={\partial loss \over \partial W2} = \begin{pmatrix} {\partial loss \over \partial z}{\partial z \over \partial w^2_{11}} \\ \\ {\partial loss \over \partial z}{\partial z \over \partial w^2_{21}} \\ \\ {\partial loss \over \partial z}{\partial z \over \partial w^2_{31}} \end{pmatrix} = \begin{pmatrix} (z-y) \cdot a^1_{1} \\ (z-y) \cdot a^1_{2} \\ (z-y) \cdot a^1_{3} \end{pmatrix} =\begin{pmatrix} a^1_{1} & a^1_{2} & a^1_{3} \end{pmatrix}^T(z-y) =A1^T(Z-Y) \tag{6}求B2的梯度 dB2={\partial loss \over \partial B2}=z-y \tag{7}|反向传播| 根据公式3和A1矩阵的形状： {\partial loss \over \partial A1} = \begin{pmatrix} {\partial loss \over \partial Z}{\partial Z \over \partial a_{11}} & {\partial loss \over \partial Z}{\partial Z \over \partial a_{12}} & {\partial loss \over \partial Z}{\partial Z \over \partial a_{13}} \end{pmatrix} = \begin{pmatrix} (z-y)w^2_{11} & (z-y)w^2_{12} & (z-y)w^2_{13} \end{pmatrix} =(z-y) \begin{pmatrix} w^2_{11} & w^2_{21} & w^2_{31} \end{pmatrix} =(z-y) \begin{pmatrix} w^2_{11} \\ w^2_{21} \\ w^2_{31} \end{pmatrix}^T=(Z-Y) \cdot W2^T \tag{8}现在来看激活函数的误差传播问题，由于公式2$A1=sigmoid(Z1)$在计算时，并没有改变矩阵的形状，相当于做了一个矩阵内逐元素的的计算，所以它的导数也应该是逐元素的计算，不改变误差矩阵的形状。根据Sigmoid激活函数的导数公式，有： {\partial A1 \over \partial Z1}=A1 \odot (1-A1) => dA1 \tag{9}所以最后到达Z1的误差矩阵是： {\partial loss \over \partial Z1}={\partial loss \over \partial Z}{\partial Z \over \partial A1}{\partial A1 \over \partial Z1} =(Z-Y) \cdot W2^T \odot dA1 => dZ1 \tag{10}有了dZ1后，再向前求W1和B1的误差，就和第5章中一样了，我们直接列在下面： dW1=X^T \cdot dZ1 \tag{11} dB1=dZ1 \tag{12}在学习MachineLearning的时候，我最烦恼的事情就是矩阵相乘时候的尺寸，和是否转置。这些操作主要是为了通过矩阵相乘，来进行批量预算，故而需要适时地通过转置调整尺寸例如这里的X矩阵，为第一层的输入，它的原始形状为（特征1， 特征2， 特征3）1行-3列这是样本一的三个特征输入，而权重矩阵是3行-1列，故用于对权重矩阵进行数值调节的dW矩阵应当与权重矩阵一致，即3行-1列，此处对X矩阵转置为3行-1列再乘上一个标量z-y 对于之前学过的两输入一输出的单神经元模型有：Z=w0(即b)+w1x1+w2x2（x为特征值）A=sigmoid(Z) [如果需要的话，先不讨论] dW1=X^T \cdot dZ1 \tag{11} dB1=dZ1 \tag{12}显然成立 而本节所讲的加入隐藏层所构成的神经网络，可以看成是两个简单过程的拼接 输入 处理 输出（第一层输出作为输入）输入 处理 输出]]></content>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maxim_Go]]></title>
    <url>%2F2019%2F10%2F08%2FMaxim-Go%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
</search>
